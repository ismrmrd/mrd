NoiseCovariance: !record
  fields:
    # Comes from Header.acquisitionSystemInformation.coilLabel
    coilLabels: CoilLabelType*
    # Comes from Header.acquisitionSystemInformation.relativeReceiverNoiseBandwidth
    receiverNoiseBandwidth: float
    # Comes from Acquisition.sampleTimeUs
    noiseDwellTimeNs: uint64
    # Number of samples used to compute matrix
    sampleCount: size
    # Noise covariance matrix with dimensions [coil, coil]
    matrix: complexfloat[,]

AcquisitionBucket: !record
  fields:
    data: Acquisition*
    ref: Acquisition*
    datastats: EncodingLimitsType*
    refstats: EncodingLimitsType*
    waveforms: WaveformUint32*

# Sampled range along E0, E1, E2 (for asymmetric echo and partial fourier)
SamplingLimits: !record
  fields:
    kspaceEncodingStep0: LimitType
    kspaceEncodingStep1: LimitType
    kspaceEncodingStep2: LimitType

SamplingDescription: !record
  fields:
    encodedFOV: FieldOfViewMm
    reconFOV: FieldOfViewMm
    encodedMatrix: MatrixSizeType
    reconMatrix: MatrixSizeType
    samplingLimits: SamplingLimits

ReconBuffer: !record
  fields:
    # Buffered Acquisition data
    data: complexfloat[loc, s, n, chan, e2, e1, e0]
    # Buffered Trajectory data
    trajectory: float[loc, s, n, e2, e1, basis, samples]
    # Buffered Density weights
    density: float[loc, s, n, e2, e1, e0]?
    # Buffered AcquisitionHeaders
    headers: AcquisitionHeader[loc, s, n, e2, e1]
    # Sampling details for these Acquisitions
    sampling: SamplingDescription

ReconAssembly: !record
  fields:
    data: ReconBuffer
    ref: ReconBuffer?

ReconData: !record
  fields:
    buffers: ReconAssembly*


ImageArray: !record
  fields:
    data: complexfloat[loc, s, n, channel, z, y, x]
    headers: ImageHeader[loc, s, n]
    meta: ImageMeta[loc, s, n]
    waveforms: WaveformUint32*


Array<T>: !array
  items: T

ArrayComplexFloat: Array<complexfloat>

# Added generic NDarray with header 

ArrayType: !enum
  values:
    spinDensityMap: 1  # in mol/m^3
    t1Map: 2           # in s
    t2Map: 3           # in s
    t2starMap: 4       # in s
    adcMap: 5          # in s/m^2
    b0Map: 6           # in Hz (offset from Image.head.measurementFreq[0])
    b1Map: 7           # in rad/s/V, channel dimension is xmit channels
    sensitivityMap: 8  # in Vm^3/mol, channel dimension is rcv channels
    gfactorMap: 9      # unaccelerated SNR/(accelerated SNR * sqrt of acceleration factor)
    userMap: 10        # custom image type with description at ImageMeta

ArrayMetaValue: [string, long, double]

ArrayMeta: string->ArrayMetaValue*  # string label and value as list of string, long, or double

ArrayDimension: !enum
  values:
    channel: 0
    z: 1
    y: 2
    x: 3
    frequency: 4
    basis: 5
    samples: 6
    loc: 7
    s: 8
    n: 9
    e2: 10
    e1: 11
    e0: 12
    time: 13

NDArrayHeader: !record
  fields:
    dimensionLabels: ArrayDimension*  # optional ordered vector of enum labels
    arrayType: ArrayType              # mandatory type of array
    meta: ArrayMeta

NDArray<T>: !record     # no computed fields as the dimension is not labeled in build time
  fields:
    head: NDArrayHeader 
    data: Array<T>

NDArrayUint16: NDArray<uint16>
NDArrayInt16: NDArray<int16>
NDArrayUint32: NDArray<uint>
NDArrayInt32: NDArray<int>
NDArrayFloat: NDArray<float>
NDArrayDouble: NDArray<double>
NDArrayComplexFloat: NDArray<complexfloat>
NDArrayComplexDouble: NDArray<complexdouble>

AnyNDArray:
  - NDArrayUint16
  - NDArrayInt16
  - NDArrayUint32
  - NDArrayInt32
  - NDArrayFloat
  - NDArrayDouble
  - NDArrayComplexFloat
  - NDArrayComplexDouble