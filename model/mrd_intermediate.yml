NoiseCovariance: !record
  fields:
    # Comes from Header.acquisitionSystemInformation.coilLabel
    coilLabels: CoilLabelType*
    # Comes from Header.acquisitionSystemInformation.relativeReceiverNoiseBandwidth
    receiverNoiseBandwidth: float
    # Comes from Acquisition.sampleTimeUs
    noiseDwellTimeNs: uint64
    # Number of samples used to compute matrix
    sampleCount: size
    # Noise covariance matrix with dimensions [coil, coil]
    matrix: complexfloat[,]

AcquisitionBucket: !record
  fields:
    data: Acquisition*
    ref: Acquisition*
    datastats: EncodingLimitsType*
    refstats: EncodingLimitsType*
    waveforms: WaveformUint32*

# Sampled range along E0, E1, E2 (for asymmetric echo and partial fourier)
SamplingLimits: !record
  fields:
    kspaceEncodingStep0: LimitType
    kspaceEncodingStep1: LimitType
    kspaceEncodingStep2: LimitType

SamplingDescription: !record
  fields:
    encodedFOV: FieldOfViewMm
    reconFOV: FieldOfViewMm
    encodedMatrix: MatrixSizeType
    reconMatrix: MatrixSizeType
    samplingLimits: SamplingLimits

ReconBuffer: !record
  fields:
    # Buffered Acquisition data
    data: complexfloat[loc, s, n, chan, e2, e1, e0]
    # Buffered Trajectory data
    trajectory: float[loc, s, n, e2, e1, basis, samples]
    # Buffered Density weights
    density: float[loc, s, n, e2, e1, e0]?
    # Buffered AcquisitionHeaders
    headers: AcquisitionHeader[loc, s, n, e2, e1]
    # Sampling details for these Acquisitions
    sampling: SamplingDescription

ReconAssembly: !record
  fields:
    data: ReconBuffer
    ref: ReconBuffer?

ReconData: !record
  fields:
    buffers: ReconAssembly*


ImageArray: !record
  fields:
    data: complexfloat[loc, s, n, channel, z, y, x]
    headers: ImageHeader[loc, s, n]
    meta: ImageMeta[loc, s, n]
    waveforms: WaveformUint32*


Array<T>: !array
  items: T

ArrayComplexFloat: Array<complexfloat>

# array type to describe maps
ArrayType: !enum
  values:
    spinDensityMap: 1  # in mol/m^3
    t1Map: 2           # in s
    t2Map: 3           # in s
    t2starMap: 4       # in s
    adcMap: 5          # in s/m^2
    b0Map: 6           # in Hz (offset from Image.head.measurementFreq[0])
    b1Map: 7           # in rad/s/V, channel dimension is transmit channels
    sensitivityMap: 8  # in Vm^3/mol, channel dimension is receive channels
    gfactorMap: 9      # unaccelerated SNR/(accelerated SNR * sqrt of acceleration factor)
    rgbaMap: 10        # rgba image with rgba dimension label
    userMap: 11        # custom image type with description at ImageMeta

ArrayMetaValue: [string, long, double]

ArrayMeta: string->ArrayMetaValue*

ArrayDimension: !enum   # labels for each dimension of NDArray in the order
  values:
    channel: 1
    z: 2
    y: 3
    x: 4
    frequency: 5
    basis: 6
    samples: 7
    loc: 8
    s: 9
    n: 10
    e2: 11
    e1: 12
    e0: 13
    rgba: 14
    timeNs: 15

ArrayHeader: !record
  fields:
    dimensionLabels: ArrayDimension*  # optional ordered vector of dimension labels
    arrayType: ArrayType?             # optional type of the array
    meta: ArrayMeta

NDArray<T>: !record                   # custom NDarray field with header
  fields:
    head: ArrayHeader
    data: Array<T>

NDArrayUint16: NDArray<uint16>
NDArrayInt16: NDArray<int16>
NDArrayUint32: NDArray<uint>
NDArrayInt32: NDArray<int>
NDArrayFloat: NDArray<float>
NDArrayDouble: NDArray<double>
NDArrayComplexFloat: NDArray<complexfloat>
NDArrayComplexDouble: NDArray<complexdouble>

# Union of all MRD NDArray types
AnyNDArray:
  - NDArrayUint16
  - NDArrayInt16
  - NDArrayUint32
  - NDArrayInt32
  - NDArrayFloat
  - NDArrayDouble
  - NDArrayComplexFloat
  - NDArrayComplexDouble
