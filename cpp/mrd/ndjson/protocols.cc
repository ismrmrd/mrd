// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "../yardl/detail/ndjson/serializers.h"
#include "protocols.h"

namespace mrd {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, mrd::AcquisitionFlags const& value);
void from_json(ordered_json const& j, mrd::AcquisitionFlags& value);

void to_json(ordered_json& j, mrd::EncodingCounters const& value);
void from_json(ordered_json const& j, mrd::EncodingCounters& value);

void to_json(ordered_json& j, mrd::AcquisitionHeader const& value);
void from_json(ordered_json const& j, mrd::AcquisitionHeader& value);

void to_json(ordered_json& j, mrd::Acquisition const& value);
void from_json(ordered_json const& j, mrd::Acquisition& value);

void to_json(ordered_json& j, mrd::PatientGender const& value);
void from_json(ordered_json const& j, mrd::PatientGender& value);

void to_json(ordered_json& j, mrd::SubjectInformationType const& value);
void from_json(ordered_json const& j, mrd::SubjectInformationType& value);

void to_json(ordered_json& j, mrd::StudyInformationType const& value);
void from_json(ordered_json const& j, mrd::StudyInformationType& value);

void to_json(ordered_json& j, mrd::PatientPosition const& value);
void from_json(ordered_json const& j, mrd::PatientPosition& value);

void to_json(ordered_json& j, mrd::ThreeDimensionalFloat const& value);
void from_json(ordered_json const& j, mrd::ThreeDimensionalFloat& value);

void to_json(ordered_json& j, mrd::MeasurementDependencyType const& value);
void from_json(ordered_json const& j, mrd::MeasurementDependencyType& value);

void to_json(ordered_json& j, mrd::ReferencedImageSequenceType const& value);
void from_json(ordered_json const& j, mrd::ReferencedImageSequenceType& value);

void to_json(ordered_json& j, mrd::MeasurementInformationType const& value);
void from_json(ordered_json const& j, mrd::MeasurementInformationType& value);

void to_json(ordered_json& j, mrd::CoilLabelType const& value);
void from_json(ordered_json const& j, mrd::CoilLabelType& value);

void to_json(ordered_json& j, mrd::AcquisitionSystemInformationType const& value);
void from_json(ordered_json const& j, mrd::AcquisitionSystemInformationType& value);

void to_json(ordered_json& j, mrd::ExperimentalConditionsType const& value);
void from_json(ordered_json const& j, mrd::ExperimentalConditionsType& value);

void to_json(ordered_json& j, mrd::MatrixSizeType const& value);
void from_json(ordered_json const& j, mrd::MatrixSizeType& value);

void to_json(ordered_json& j, mrd::FieldOfViewMm const& value);
void from_json(ordered_json const& j, mrd::FieldOfViewMm& value);

void to_json(ordered_json& j, mrd::EncodingSpaceType const& value);
void from_json(ordered_json const& j, mrd::EncodingSpaceType& value);

void to_json(ordered_json& j, mrd::LimitType const& value);
void from_json(ordered_json const& j, mrd::LimitType& value);

void to_json(ordered_json& j, mrd::EncodingLimitsType const& value);
void from_json(ordered_json const& j, mrd::EncodingLimitsType& value);

void to_json(ordered_json& j, mrd::Trajectory const& value);
void from_json(ordered_json const& j, mrd::Trajectory& value);

void to_json(ordered_json& j, mrd::UserParameterLongType const& value);
void from_json(ordered_json const& j, mrd::UserParameterLongType& value);

void to_json(ordered_json& j, mrd::UserParameterDoubleType const& value);
void from_json(ordered_json const& j, mrd::UserParameterDoubleType& value);

void to_json(ordered_json& j, mrd::UserParameterStringType const& value);
void from_json(ordered_json const& j, mrd::UserParameterStringType& value);

void to_json(ordered_json& j, mrd::TrajectoryDescriptionType const& value);
void from_json(ordered_json const& j, mrd::TrajectoryDescriptionType& value);

void to_json(ordered_json& j, mrd::AccelerationFactorType const& value);
void from_json(ordered_json const& j, mrd::AccelerationFactorType& value);

void to_json(ordered_json& j, mrd::CalibrationMode const& value);
void from_json(ordered_json const& j, mrd::CalibrationMode& value);

void to_json(ordered_json& j, mrd::InterleavingDimension const& value);
void from_json(ordered_json const& j, mrd::InterleavingDimension& value);

void to_json(ordered_json& j, mrd::MultibandSpacingType const& value);
void from_json(ordered_json const& j, mrd::MultibandSpacingType& value);

void to_json(ordered_json& j, mrd::Calibration const& value);
void from_json(ordered_json const& j, mrd::Calibration& value);

void to_json(ordered_json& j, mrd::MultibandType const& value);
void from_json(ordered_json const& j, mrd::MultibandType& value);

void to_json(ordered_json& j, mrd::ParallelImagingType const& value);
void from_json(ordered_json const& j, mrd::ParallelImagingType& value);

void to_json(ordered_json& j, mrd::EncodingType const& value);
void from_json(ordered_json const& j, mrd::EncodingType& value);

void to_json(ordered_json& j, mrd::DiffusionDimension const& value);
void from_json(ordered_json const& j, mrd::DiffusionDimension& value);

void to_json(ordered_json& j, mrd::GradientDirectionType const& value);
void from_json(ordered_json const& j, mrd::GradientDirectionType& value);

void to_json(ordered_json& j, mrd::DiffusionType const& value);
void from_json(ordered_json const& j, mrd::DiffusionType& value);

void to_json(ordered_json& j, mrd::SequenceParametersType const& value);
void from_json(ordered_json const& j, mrd::SequenceParametersType& value);

void to_json(ordered_json& j, mrd::UserParameterBase64Type const& value);
void from_json(ordered_json const& j, mrd::UserParameterBase64Type& value);

void to_json(ordered_json& j, mrd::UserParametersType const& value);
void from_json(ordered_json const& j, mrd::UserParametersType& value);

void to_json(ordered_json& j, mrd::WaveformType const& value);
void from_json(ordered_json const& j, mrd::WaveformType& value);

void to_json(ordered_json& j, mrd::WaveformInformationType const& value);
void from_json(ordered_json const& j, mrd::WaveformInformationType& value);

void to_json(ordered_json& j, mrd::Header const& value);
void from_json(ordered_json const& j, mrd::Header& value);

void to_json(ordered_json& j, mrd::ImageFlags const& value);
void from_json(ordered_json const& j, mrd::ImageFlags& value);

void to_json(ordered_json& j, mrd::ImageType const& value);
void from_json(ordered_json const& j, mrd::ImageType& value);

void to_json(ordered_json& j, mrd::ImageHeader const& value);
void from_json(ordered_json const& j, mrd::ImageHeader& value);

template <typename T>
void to_json(ordered_json& j, mrd::Image<T> const& value);
template <typename T>
void from_json(ordered_json const& j, mrd::Image<T>& value);

void to_json(ordered_json& j, mrd::NoiseCovariance const& value);
void from_json(ordered_json const& j, mrd::NoiseCovariance& value);

template <typename T>
void to_json(ordered_json& j, mrd::Waveform<T> const& value);
template <typename T>
void from_json(ordered_json const& j, mrd::Waveform<T>& value);

void to_json(ordered_json& j, mrd::AcquisitionBucket const& value);
void from_json(ordered_json const& j, mrd::AcquisitionBucket& value);

void to_json(ordered_json& j, mrd::SamplingLimits const& value);
void from_json(ordered_json const& j, mrd::SamplingLimits& value);

void to_json(ordered_json& j, mrd::SamplingDescription const& value);
void from_json(ordered_json const& j, mrd::SamplingDescription& value);

void to_json(ordered_json& j, mrd::ReconBuffer const& value);
void from_json(ordered_json const& j, mrd::ReconBuffer& value);

void to_json(ordered_json& j, mrd::ReconAssembly const& value);
void from_json(ordered_json const& j, mrd::ReconAssembly& value);

void to_json(ordered_json& j, mrd::ReconData const& value);
void from_json(ordered_json const& j, mrd::ReconData& value);

void to_json(ordered_json& j, mrd::ImageArray const& value);
void from_json(ordered_json const& j, mrd::ImageArray& value);

} // namespace mrd

NLOHMANN_JSON_NAMESPACE_BEGIN

template <>
struct adl_serializer<std::variant<std::string, int64_t, double>> {
  static void to_json(ordered_json& j, std::variant<std::string, int64_t, double> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"string", std::get<std::string>(value)} };
        break;
      case 1:
        j = ordered_json{ {"int64", std::get<int64_t>(value)} };
        break;
      case 2:
        j = ordered_json{ {"float64", std::get<double>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<std::string, int64_t, double>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "string") {
      value = it.value().get<std::string>();
      return;
    }
    if (tag == "int64") {
      value = it.value().get<int64_t>();
      return;
    }
    if (tag == "float64") {
      value = it.value().get<double>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<mrd::Image<uint16_t>, mrd::Image<int16_t>, mrd::Image<uint32_t>, mrd::Image<int32_t>, mrd::Image<float>, mrd::Image<double>, mrd::Image<std::complex<float>>, mrd::Image<std::complex<double>>>> {
  static void to_json(ordered_json& j, std::variant<mrd::Image<uint16_t>, mrd::Image<int16_t>, mrd::Image<uint32_t>, mrd::Image<int32_t>, mrd::Image<float>, mrd::Image<double>, mrd::Image<std::complex<float>>, mrd::Image<std::complex<double>>> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"ImageUint16", std::get<mrd::Image<uint16_t>>(value)} };
        break;
      case 1:
        j = ordered_json{ {"ImageInt16", std::get<mrd::Image<int16_t>>(value)} };
        break;
      case 2:
        j = ordered_json{ {"ImageUint32", std::get<mrd::Image<uint32_t>>(value)} };
        break;
      case 3:
        j = ordered_json{ {"ImageInt32", std::get<mrd::Image<int32_t>>(value)} };
        break;
      case 4:
        j = ordered_json{ {"ImageFloat", std::get<mrd::Image<float>>(value)} };
        break;
      case 5:
        j = ordered_json{ {"ImageDouble", std::get<mrd::Image<double>>(value)} };
        break;
      case 6:
        j = ordered_json{ {"ImageComplexFloat", std::get<mrd::Image<std::complex<float>>>(value)} };
        break;
      case 7:
        j = ordered_json{ {"ImageComplexDouble", std::get<mrd::Image<std::complex<double>>>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<mrd::Image<uint16_t>, mrd::Image<int16_t>, mrd::Image<uint32_t>, mrd::Image<int32_t>, mrd::Image<float>, mrd::Image<double>, mrd::Image<std::complex<float>>, mrd::Image<std::complex<double>>>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "ImageUint16") {
      value = it.value().get<mrd::Image<uint16_t>>();
      return;
    }
    if (tag == "ImageInt16") {
      value = it.value().get<mrd::Image<int16_t>>();
      return;
    }
    if (tag == "ImageUint32") {
      value = it.value().get<mrd::Image<uint32_t>>();
      return;
    }
    if (tag == "ImageInt32") {
      value = it.value().get<mrd::Image<int32_t>>();
      return;
    }
    if (tag == "ImageFloat") {
      value = it.value().get<mrd::Image<float>>();
      return;
    }
    if (tag == "ImageDouble") {
      value = it.value().get<mrd::Image<double>>();
      return;
    }
    if (tag == "ImageComplexFloat") {
      value = it.value().get<mrd::Image<std::complex<float>>>();
      return;
    }
    if (tag == "ImageComplexDouble") {
      value = it.value().get<mrd::Image<std::complex<double>>>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<mrd::Acquisition, mrd::Waveform<uint32_t>, mrd::Image<uint16_t>, mrd::Image<int16_t>, mrd::Image<uint32_t>, mrd::Image<int32_t>, mrd::Image<float>, mrd::Image<double>, mrd::Image<std::complex<float>>, mrd::Image<std::complex<double>>, mrd::AcquisitionBucket, mrd::ReconData, yardl::DynamicNDArray<std::complex<float>>, mrd::ImageArray>> {
  static void to_json(ordered_json& j, std::variant<mrd::Acquisition, mrd::Waveform<uint32_t>, mrd::Image<uint16_t>, mrd::Image<int16_t>, mrd::Image<uint32_t>, mrd::Image<int32_t>, mrd::Image<float>, mrd::Image<double>, mrd::Image<std::complex<float>>, mrd::Image<std::complex<double>>, mrd::AcquisitionBucket, mrd::ReconData, yardl::DynamicNDArray<std::complex<float>>, mrd::ImageArray> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"Acquisition", std::get<mrd::Acquisition>(value)} };
        break;
      case 1:
        j = ordered_json{ {"WaveformUint32", std::get<mrd::Waveform<uint32_t>>(value)} };
        break;
      case 2:
        j = ordered_json{ {"ImageUint16", std::get<mrd::Image<uint16_t>>(value)} };
        break;
      case 3:
        j = ordered_json{ {"ImageInt16", std::get<mrd::Image<int16_t>>(value)} };
        break;
      case 4:
        j = ordered_json{ {"ImageUint32", std::get<mrd::Image<uint32_t>>(value)} };
        break;
      case 5:
        j = ordered_json{ {"ImageInt32", std::get<mrd::Image<int32_t>>(value)} };
        break;
      case 6:
        j = ordered_json{ {"ImageFloat", std::get<mrd::Image<float>>(value)} };
        break;
      case 7:
        j = ordered_json{ {"ImageDouble", std::get<mrd::Image<double>>(value)} };
        break;
      case 8:
        j = ordered_json{ {"ImageComplexFloat", std::get<mrd::Image<std::complex<float>>>(value)} };
        break;
      case 9:
        j = ordered_json{ {"ImageComplexDouble", std::get<mrd::Image<std::complex<double>>>(value)} };
        break;
      case 10:
        j = ordered_json{ {"AcquisitionBucket", std::get<mrd::AcquisitionBucket>(value)} };
        break;
      case 11:
        j = ordered_json{ {"ReconData", std::get<mrd::ReconData>(value)} };
        break;
      case 12:
        j = ordered_json{ {"ArrayComplexFloat", std::get<yardl::DynamicNDArray<std::complex<float>>>(value)} };
        break;
      case 13:
        j = ordered_json{ {"ImageArray", std::get<mrd::ImageArray>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<mrd::Acquisition, mrd::Waveform<uint32_t>, mrd::Image<uint16_t>, mrd::Image<int16_t>, mrd::Image<uint32_t>, mrd::Image<int32_t>, mrd::Image<float>, mrd::Image<double>, mrd::Image<std::complex<float>>, mrd::Image<std::complex<double>>, mrd::AcquisitionBucket, mrd::ReconData, yardl::DynamicNDArray<std::complex<float>>, mrd::ImageArray>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "Acquisition") {
      value = it.value().get<mrd::Acquisition>();
      return;
    }
    if (tag == "WaveformUint32") {
      value = it.value().get<mrd::Waveform<uint32_t>>();
      return;
    }
    if (tag == "ImageUint16") {
      value = it.value().get<mrd::Image<uint16_t>>();
      return;
    }
    if (tag == "ImageInt16") {
      value = it.value().get<mrd::Image<int16_t>>();
      return;
    }
    if (tag == "ImageUint32") {
      value = it.value().get<mrd::Image<uint32_t>>();
      return;
    }
    if (tag == "ImageInt32") {
      value = it.value().get<mrd::Image<int32_t>>();
      return;
    }
    if (tag == "ImageFloat") {
      value = it.value().get<mrd::Image<float>>();
      return;
    }
    if (tag == "ImageDouble") {
      value = it.value().get<mrd::Image<double>>();
      return;
    }
    if (tag == "ImageComplexFloat") {
      value = it.value().get<mrd::Image<std::complex<float>>>();
      return;
    }
    if (tag == "ImageComplexDouble") {
      value = it.value().get<mrd::Image<std::complex<double>>>();
      return;
    }
    if (tag == "AcquisitionBucket") {
      value = it.value().get<mrd::AcquisitionBucket>();
      return;
    }
    if (tag == "ReconData") {
      value = it.value().get<mrd::ReconData>();
      return;
    }
    if (tag == "ArrayComplexFloat") {
      value = it.value().get<yardl::DynamicNDArray<std::complex<float>>>();
      return;
    }
    if (tag == "ImageArray") {
      value = it.value().get<mrd::ImageArray>();
      return;
    }
  }
};

NLOHMANN_JSON_NAMESPACE_END

namespace mrd {
using ordered_json = nlohmann::ordered_json;

namespace {
std::unordered_map<std::string, mrd::AcquisitionFlags> const __AcquisitionFlags_values = {
  {"firstInEncodeStep1", mrd::AcquisitionFlags::kFirstInEncodeStep1},
  {"lastInEncodeStep1", mrd::AcquisitionFlags::kLastInEncodeStep1},
  {"firstInEncodeStep2", mrd::AcquisitionFlags::kFirstInEncodeStep2},
  {"lastInEncodeStep2", mrd::AcquisitionFlags::kLastInEncodeStep2},
  {"firstInAverage", mrd::AcquisitionFlags::kFirstInAverage},
  {"lastInAverage", mrd::AcquisitionFlags::kLastInAverage},
  {"firstInSlice", mrd::AcquisitionFlags::kFirstInSlice},
  {"lastInSlice", mrd::AcquisitionFlags::kLastInSlice},
  {"firstInContrast", mrd::AcquisitionFlags::kFirstInContrast},
  {"lastInContrast", mrd::AcquisitionFlags::kLastInContrast},
  {"firstInPhase", mrd::AcquisitionFlags::kFirstInPhase},
  {"lastInPhase", mrd::AcquisitionFlags::kLastInPhase},
  {"firstInRepetition", mrd::AcquisitionFlags::kFirstInRepetition},
  {"lastInRepetition", mrd::AcquisitionFlags::kLastInRepetition},
  {"firstInSet", mrd::AcquisitionFlags::kFirstInSet},
  {"lastInSet", mrd::AcquisitionFlags::kLastInSet},
  {"firstInSegment", mrd::AcquisitionFlags::kFirstInSegment},
  {"lastInSegment", mrd::AcquisitionFlags::kLastInSegment},
  {"isNoiseMeasurement", mrd::AcquisitionFlags::kIsNoiseMeasurement},
  {"isParallelCalibration", mrd::AcquisitionFlags::kIsParallelCalibration},
  {"isParallelCalibrationAndImaging", mrd::AcquisitionFlags::kIsParallelCalibrationAndImaging},
  {"isReverse", mrd::AcquisitionFlags::kIsReverse},
  {"isNavigationData", mrd::AcquisitionFlags::kIsNavigationData},
  {"isPhasecorrData", mrd::AcquisitionFlags::kIsPhasecorrData},
  {"lastInMeasurement", mrd::AcquisitionFlags::kLastInMeasurement},
  {"isHpfeedbackData", mrd::AcquisitionFlags::kIsHpfeedbackData},
  {"isDummyscanData", mrd::AcquisitionFlags::kIsDummyscanData},
  {"isRtfeedbackData", mrd::AcquisitionFlags::kIsRtfeedbackData},
  {"isSurfacecoilcorrectionscanData", mrd::AcquisitionFlags::kIsSurfacecoilcorrectionscanData},
  {"isPhaseStabilizationReference", mrd::AcquisitionFlags::kIsPhaseStabilizationReference},
  {"isPhaseStabilization", mrd::AcquisitionFlags::kIsPhaseStabilization},
};
} //namespace

void to_json(ordered_json& j, mrd::AcquisitionFlags const& value) {
  auto arr = ordered_json::array();
  if (value == 0) {
    j = arr;
    return;
  }
  auto remaining = value;
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInEncodeStep1)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInEncodeStep1);
    arr.push_back("firstInEncodeStep1");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInEncodeStep1)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInEncodeStep1);
    arr.push_back("lastInEncodeStep1");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInEncodeStep2)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInEncodeStep2);
    arr.push_back("firstInEncodeStep2");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInEncodeStep2)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInEncodeStep2);
    arr.push_back("lastInEncodeStep2");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInAverage)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInAverage);
    arr.push_back("firstInAverage");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInAverage)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInAverage);
    arr.push_back("lastInAverage");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInSlice)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInSlice);
    arr.push_back("firstInSlice");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInSlice)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInSlice);
    arr.push_back("lastInSlice");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInContrast)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInContrast);
    arr.push_back("firstInContrast");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInContrast)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInContrast);
    arr.push_back("lastInContrast");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInPhase)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInPhase);
    arr.push_back("firstInPhase");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInPhase)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInPhase);
    arr.push_back("lastInPhase");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInRepetition)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInRepetition);
    arr.push_back("firstInRepetition");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInRepetition)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInRepetition);
    arr.push_back("lastInRepetition");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInSet)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInSet);
    arr.push_back("firstInSet");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInSet)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInSet);
    arr.push_back("lastInSet");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kFirstInSegment)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kFirstInSegment);
    arr.push_back("firstInSegment");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInSegment)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInSegment);
    arr.push_back("lastInSegment");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsNoiseMeasurement)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsNoiseMeasurement);
    arr.push_back("isNoiseMeasurement");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsParallelCalibration)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsParallelCalibration);
    arr.push_back("isParallelCalibration");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsParallelCalibrationAndImaging)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsParallelCalibrationAndImaging);
    arr.push_back("isParallelCalibrationAndImaging");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsReverse)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsReverse);
    arr.push_back("isReverse");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsNavigationData)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsNavigationData);
    arr.push_back("isNavigationData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsPhasecorrData)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsPhasecorrData);
    arr.push_back("isPhasecorrData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kLastInMeasurement)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kLastInMeasurement);
    arr.push_back("lastInMeasurement");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsHpfeedbackData)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsHpfeedbackData);
    arr.push_back("isHpfeedbackData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsDummyscanData)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsDummyscanData);
    arr.push_back("isDummyscanData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsRtfeedbackData)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsRtfeedbackData);
    arr.push_back("isRtfeedbackData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsSurfacecoilcorrectionscanData)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsSurfacecoilcorrectionscanData);
    arr.push_back("isSurfacecoilcorrectionscanData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsPhaseStabilizationReference)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsPhaseStabilizationReference);
    arr.push_back("isPhaseStabilizationReference");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::AcquisitionFlags::kIsPhaseStabilization)) {
    remaining.UnsetFlags(mrd::AcquisitionFlags::kIsPhaseStabilization);
    arr.push_back("isPhaseStabilization");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  j = value.Value();
}

void from_json(ordered_json const& j, mrd::AcquisitionFlags& value) {
  if (j.is_number()) {
    using underlying_type = typename mrd::AcquisitionFlags::value_type;
    value = j.get<underlying_type>();
    return;
  }
  std::vector<std::string> arr = j;
  value = {};
  for (auto const& item : arr) {
    if (auto res = __AcquisitionFlags_values.find(item); res != __AcquisitionFlags_values.end()) {
      value |= res->second;
      continue;
    }
    throw std::runtime_error("Invalid enum value '" + item + "' for enum mrd::AcquisitionFlags");
  }
}

void to_json(ordered_json& j, mrd::EncodingCounters const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encode_step_1)) {
    j.push_back({"kspaceEncodeStep1", value.kspace_encode_step_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encode_step_2)) {
    j.push_back({"kspaceEncodeStep2", value.kspace_encode_step_2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.average)) {
    j.push_back({"average", value.average});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.slice)) {
    j.push_back({"slice", value.slice});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.contrast)) {
    j.push_back({"contrast", value.contrast});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.phase)) {
    j.push_back({"phase", value.phase});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.repetition)) {
    j.push_back({"repetition", value.repetition});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.set)) {
    j.push_back({"set", value.set});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.segment)) {
    j.push_back({"segment", value.segment});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user)) {
    j.push_back({"user", value.user});
  }
}

void from_json(ordered_json const& j, mrd::EncodingCounters& value) {
  if (auto it = j.find("kspaceEncodeStep1"); it != j.end()) {
    it->get_to(value.kspace_encode_step_1);
  }
  if (auto it = j.find("kspaceEncodeStep2"); it != j.end()) {
    it->get_to(value.kspace_encode_step_2);
  }
  if (auto it = j.find("average"); it != j.end()) {
    it->get_to(value.average);
  }
  if (auto it = j.find("slice"); it != j.end()) {
    it->get_to(value.slice);
  }
  if (auto it = j.find("contrast"); it != j.end()) {
    it->get_to(value.contrast);
  }
  if (auto it = j.find("phase"); it != j.end()) {
    it->get_to(value.phase);
  }
  if (auto it = j.find("repetition"); it != j.end()) {
    it->get_to(value.repetition);
  }
  if (auto it = j.find("set"); it != j.end()) {
    it->get_to(value.set);
  }
  if (auto it = j.find("segment"); it != j.end()) {
    it->get_to(value.segment);
  }
  if (auto it = j.find("user"); it != j.end()) {
    it->get_to(value.user);
  }
}

void to_json(ordered_json& j, mrd::AcquisitionHeader const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flags)) {
    j.push_back({"flags", value.flags});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.idx)) {
    j.push_back({"idx", value.idx});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_uid)) {
    j.push_back({"measurementUid", value.measurement_uid});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.scan_counter)) {
    j.push_back({"scanCounter", value.scan_counter});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.acquisition_time_stamp)) {
    j.push_back({"acquisitionTimeStamp", value.acquisition_time_stamp});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.physiology_time_stamp)) {
    j.push_back({"physiologyTimeStamp", value.physiology_time_stamp});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.channel_order)) {
    j.push_back({"channelOrder", value.channel_order});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.discard_pre)) {
    j.push_back({"discardPre", value.discard_pre});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.discard_post)) {
    j.push_back({"discardPost", value.discard_post});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.center_sample)) {
    j.push_back({"centerSample", value.center_sample});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.encoding_space_ref)) {
    j.push_back({"encodingSpaceRef", value.encoding_space_ref});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sample_time_us)) {
    j.push_back({"sampleTimeUs", value.sample_time_us});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.position)) {
    j.push_back({"position", value.position});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.read_dir)) {
    j.push_back({"readDir", value.read_dir});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.phase_dir)) {
    j.push_back({"phaseDir", value.phase_dir});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.slice_dir)) {
    j.push_back({"sliceDir", value.slice_dir});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_table_position)) {
    j.push_back({"patientTablePosition", value.patient_table_position});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_int)) {
    j.push_back({"userInt", value.user_int});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_float)) {
    j.push_back({"userFloat", value.user_float});
  }
}

void from_json(ordered_json const& j, mrd::AcquisitionHeader& value) {
  if (auto it = j.find("flags"); it != j.end()) {
    it->get_to(value.flags);
  }
  if (auto it = j.find("idx"); it != j.end()) {
    it->get_to(value.idx);
  }
  if (auto it = j.find("measurementUid"); it != j.end()) {
    it->get_to(value.measurement_uid);
  }
  if (auto it = j.find("scanCounter"); it != j.end()) {
    it->get_to(value.scan_counter);
  }
  if (auto it = j.find("acquisitionTimeStamp"); it != j.end()) {
    it->get_to(value.acquisition_time_stamp);
  }
  if (auto it = j.find("physiologyTimeStamp"); it != j.end()) {
    it->get_to(value.physiology_time_stamp);
  }
  if (auto it = j.find("channelOrder"); it != j.end()) {
    it->get_to(value.channel_order);
  }
  if (auto it = j.find("discardPre"); it != j.end()) {
    it->get_to(value.discard_pre);
  }
  if (auto it = j.find("discardPost"); it != j.end()) {
    it->get_to(value.discard_post);
  }
  if (auto it = j.find("centerSample"); it != j.end()) {
    it->get_to(value.center_sample);
  }
  if (auto it = j.find("encodingSpaceRef"); it != j.end()) {
    it->get_to(value.encoding_space_ref);
  }
  if (auto it = j.find("sampleTimeUs"); it != j.end()) {
    it->get_to(value.sample_time_us);
  }
  if (auto it = j.find("position"); it != j.end()) {
    it->get_to(value.position);
  }
  if (auto it = j.find("readDir"); it != j.end()) {
    it->get_to(value.read_dir);
  }
  if (auto it = j.find("phaseDir"); it != j.end()) {
    it->get_to(value.phase_dir);
  }
  if (auto it = j.find("sliceDir"); it != j.end()) {
    it->get_to(value.slice_dir);
  }
  if (auto it = j.find("patientTablePosition"); it != j.end()) {
    it->get_to(value.patient_table_position);
  }
  if (auto it = j.find("userInt"); it != j.end()) {
    it->get_to(value.user_int);
  }
  if (auto it = j.find("userFloat"); it != j.end()) {
    it->get_to(value.user_float);
  }
}

void to_json(ordered_json& j, mrd::Acquisition const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.head)) {
    j.push_back({"head", value.head});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.trajectory)) {
    j.push_back({"trajectory", value.trajectory});
  }
}

void from_json(ordered_json const& j, mrd::Acquisition& value) {
  if (auto it = j.find("head"); it != j.end()) {
    it->get_to(value.head);
  }
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("trajectory"); it != j.end()) {
    it->get_to(value.trajectory);
  }
}

namespace {
std::unordered_map<std::string, mrd::PatientGender> const __PatientGender_values = {
  {"m", mrd::PatientGender::kM},
  {"f", mrd::PatientGender::kF},
  {"o", mrd::PatientGender::kO},
};
} //namespace

void to_json(ordered_json& j, mrd::PatientGender const& value) {
  switch (value) {
    case mrd::PatientGender::kM:
      j = "m";
      break;
    case mrd::PatientGender::kF:
      j = "f";
      break;
    case mrd::PatientGender::kO:
      j = "o";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::PatientGender>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::PatientGender& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __PatientGender_values.find(symbol); res != __PatientGender_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::PatientGender");
  }
  using underlying_type = typename std::underlying_type<mrd::PatientGender>::type;
  value = static_cast<mrd::PatientGender>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::SubjectInformationType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_name)) {
    j.push_back({"patientName", value.patient_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_weight_kg)) {
    j.push_back({"patientWeightKg", value.patient_weight_kg});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_height_m)) {
    j.push_back({"patientHeightM", value.patient_height_m});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_id)) {
    j.push_back({"patientID", value.patient_id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_birthdate)) {
    j.push_back({"patientBirthdate", value.patient_birthdate});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_gender)) {
    j.push_back({"patientGender", value.patient_gender});
  }
}

void from_json(ordered_json const& j, mrd::SubjectInformationType& value) {
  if (auto it = j.find("patientName"); it != j.end()) {
    it->get_to(value.patient_name);
  }
  if (auto it = j.find("patientWeightKg"); it != j.end()) {
    it->get_to(value.patient_weight_kg);
  }
  if (auto it = j.find("patientHeightM"); it != j.end()) {
    it->get_to(value.patient_height_m);
  }
  if (auto it = j.find("patientID"); it != j.end()) {
    it->get_to(value.patient_id);
  }
  if (auto it = j.find("patientBirthdate"); it != j.end()) {
    it->get_to(value.patient_birthdate);
  }
  if (auto it = j.find("patientGender"); it != j.end()) {
    it->get_to(value.patient_gender);
  }
}

void to_json(ordered_json& j, mrd::StudyInformationType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.study_date)) {
    j.push_back({"studyDate", value.study_date});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.study_time)) {
    j.push_back({"studyTime", value.study_time});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.study_id)) {
    j.push_back({"studyID", value.study_id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.accession_number)) {
    j.push_back({"accessionNumber", value.accession_number});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.referring_physician_name)) {
    j.push_back({"referringPhysicianName", value.referring_physician_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.study_description)) {
    j.push_back({"studyDescription", value.study_description});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.study_instance_uid)) {
    j.push_back({"studyInstanceUID", value.study_instance_uid});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.body_part_examined)) {
    j.push_back({"bodyPartExamined", value.body_part_examined});
  }
}

void from_json(ordered_json const& j, mrd::StudyInformationType& value) {
  if (auto it = j.find("studyDate"); it != j.end()) {
    it->get_to(value.study_date);
  }
  if (auto it = j.find("studyTime"); it != j.end()) {
    it->get_to(value.study_time);
  }
  if (auto it = j.find("studyID"); it != j.end()) {
    it->get_to(value.study_id);
  }
  if (auto it = j.find("accessionNumber"); it != j.end()) {
    it->get_to(value.accession_number);
  }
  if (auto it = j.find("referringPhysicianName"); it != j.end()) {
    it->get_to(value.referring_physician_name);
  }
  if (auto it = j.find("studyDescription"); it != j.end()) {
    it->get_to(value.study_description);
  }
  if (auto it = j.find("studyInstanceUID"); it != j.end()) {
    it->get_to(value.study_instance_uid);
  }
  if (auto it = j.find("bodyPartExamined"); it != j.end()) {
    it->get_to(value.body_part_examined);
  }
}

namespace {
std::unordered_map<std::string, mrd::PatientPosition> const __PatientPosition_values = {
  {"hFP", mrd::PatientPosition::kHFP},
  {"hFS", mrd::PatientPosition::kHFS},
  {"hFDR", mrd::PatientPosition::kHFDR},
  {"hFDL", mrd::PatientPosition::kHFDL},
  {"fFP", mrd::PatientPosition::kFFP},
  {"fFS", mrd::PatientPosition::kFFS},
  {"fFDR", mrd::PatientPosition::kFFDR},
  {"fFDL", mrd::PatientPosition::kFFDL},
};
} //namespace

void to_json(ordered_json& j, mrd::PatientPosition const& value) {
  switch (value) {
    case mrd::PatientPosition::kHFP:
      j = "hFP";
      break;
    case mrd::PatientPosition::kHFS:
      j = "hFS";
      break;
    case mrd::PatientPosition::kHFDR:
      j = "hFDR";
      break;
    case mrd::PatientPosition::kHFDL:
      j = "hFDL";
      break;
    case mrd::PatientPosition::kFFP:
      j = "fFP";
      break;
    case mrd::PatientPosition::kFFS:
      j = "fFS";
      break;
    case mrd::PatientPosition::kFFDR:
      j = "fFDR";
      break;
    case mrd::PatientPosition::kFFDL:
      j = "fFDL";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::PatientPosition>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::PatientPosition& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __PatientPosition_values.find(symbol); res != __PatientPosition_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::PatientPosition");
  }
  using underlying_type = typename std::underlying_type<mrd::PatientPosition>::type;
  value = static_cast<mrd::PatientPosition>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::ThreeDimensionalFloat const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.x)) {
    j.push_back({"x", value.x});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.y)) {
    j.push_back({"y", value.y});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.z)) {
    j.push_back({"z", value.z});
  }
}

void from_json(ordered_json const& j, mrd::ThreeDimensionalFloat& value) {
  if (auto it = j.find("x"); it != j.end()) {
    it->get_to(value.x);
  }
  if (auto it = j.find("y"); it != j.end()) {
    it->get_to(value.y);
  }
  if (auto it = j.find("z"); it != j.end()) {
    it->get_to(value.z);
  }
}

void to_json(ordered_json& j, mrd::MeasurementDependencyType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.dependency_type)) {
    j.push_back({"dependencyType", value.dependency_type});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_id)) {
    j.push_back({"measurementID", value.measurement_id});
  }
}

void from_json(ordered_json const& j, mrd::MeasurementDependencyType& value) {
  if (auto it = j.find("dependencyType"); it != j.end()) {
    it->get_to(value.dependency_type);
  }
  if (auto it = j.find("measurementID"); it != j.end()) {
    it->get_to(value.measurement_id);
  }
}

void to_json(ordered_json& j, mrd::ReferencedImageSequenceType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.referenced_sop_instance_uid)) {
    j.push_back({"referencedSOPInstanceUID", value.referenced_sop_instance_uid});
  }
}

void from_json(ordered_json const& j, mrd::ReferencedImageSequenceType& value) {
  if (auto it = j.find("referencedSOPInstanceUID"); it != j.end()) {
    it->get_to(value.referenced_sop_instance_uid);
  }
}

void to_json(ordered_json& j, mrd::MeasurementInformationType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_id)) {
    j.push_back({"measurementID", value.measurement_id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.series_date)) {
    j.push_back({"seriesDate", value.series_date});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.series_time)) {
    j.push_back({"seriesTime", value.series_time});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_position)) {
    j.push_back({"patientPosition", value.patient_position});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.relative_table_position)) {
    j.push_back({"relativeTablePosition", value.relative_table_position});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.initial_series_number)) {
    j.push_back({"initialSeriesNumber", value.initial_series_number});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.protocol_name)) {
    j.push_back({"protocolName", value.protocol_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sequence_name)) {
    j.push_back({"sequenceName", value.sequence_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.series_description)) {
    j.push_back({"seriesDescription", value.series_description});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_dependency)) {
    j.push_back({"measurementDependency", value.measurement_dependency});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.series_instance_uid_root)) {
    j.push_back({"seriesInstanceUIDRoot", value.series_instance_uid_root});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.frame_of_reference_uid)) {
    j.push_back({"frameOfReferenceUID", value.frame_of_reference_uid});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.referenced_image_sequence)) {
    j.push_back({"referencedImageSequence", value.referenced_image_sequence});
  }
}

void from_json(ordered_json const& j, mrd::MeasurementInformationType& value) {
  if (auto it = j.find("measurementID"); it != j.end()) {
    it->get_to(value.measurement_id);
  }
  if (auto it = j.find("seriesDate"); it != j.end()) {
    it->get_to(value.series_date);
  }
  if (auto it = j.find("seriesTime"); it != j.end()) {
    it->get_to(value.series_time);
  }
  if (auto it = j.find("patientPosition"); it != j.end()) {
    it->get_to(value.patient_position);
  }
  if (auto it = j.find("relativeTablePosition"); it != j.end()) {
    it->get_to(value.relative_table_position);
  }
  if (auto it = j.find("initialSeriesNumber"); it != j.end()) {
    it->get_to(value.initial_series_number);
  }
  if (auto it = j.find("protocolName"); it != j.end()) {
    it->get_to(value.protocol_name);
  }
  if (auto it = j.find("sequenceName"); it != j.end()) {
    it->get_to(value.sequence_name);
  }
  if (auto it = j.find("seriesDescription"); it != j.end()) {
    it->get_to(value.series_description);
  }
  if (auto it = j.find("measurementDependency"); it != j.end()) {
    it->get_to(value.measurement_dependency);
  }
  if (auto it = j.find("seriesInstanceUIDRoot"); it != j.end()) {
    it->get_to(value.series_instance_uid_root);
  }
  if (auto it = j.find("frameOfReferenceUID"); it != j.end()) {
    it->get_to(value.frame_of_reference_uid);
  }
  if (auto it = j.find("referencedImageSequence"); it != j.end()) {
    it->get_to(value.referenced_image_sequence);
  }
}

void to_json(ordered_json& j, mrd::CoilLabelType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.coil_number)) {
    j.push_back({"coilNumber", value.coil_number});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.coil_name)) {
    j.push_back({"coilName", value.coil_name});
  }
}

void from_json(ordered_json const& j, mrd::CoilLabelType& value) {
  if (auto it = j.find("coilNumber"); it != j.end()) {
    it->get_to(value.coil_number);
  }
  if (auto it = j.find("coilName"); it != j.end()) {
    it->get_to(value.coil_name);
  }
}

void to_json(ordered_json& j, mrd::AcquisitionSystemInformationType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.system_vendor)) {
    j.push_back({"systemVendor", value.system_vendor});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.system_model)) {
    j.push_back({"systemModel", value.system_model});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.system_field_strength_t)) {
    j.push_back({"systemFieldStrengthT", value.system_field_strength_t});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.relative_receiver_noise_bandwidth)) {
    j.push_back({"relativeReceiverNoiseBandwidth", value.relative_receiver_noise_bandwidth});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.receiver_channels)) {
    j.push_back({"receiverChannels", value.receiver_channels});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.coil_label)) {
    j.push_back({"coilLabel", value.coil_label});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.institution_name)) {
    j.push_back({"institutionName", value.institution_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.station_name)) {
    j.push_back({"stationName", value.station_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.device_id)) {
    j.push_back({"deviceID", value.device_id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.device_serial_number)) {
    j.push_back({"deviceSerialNumber", value.device_serial_number});
  }
}

void from_json(ordered_json const& j, mrd::AcquisitionSystemInformationType& value) {
  if (auto it = j.find("systemVendor"); it != j.end()) {
    it->get_to(value.system_vendor);
  }
  if (auto it = j.find("systemModel"); it != j.end()) {
    it->get_to(value.system_model);
  }
  if (auto it = j.find("systemFieldStrengthT"); it != j.end()) {
    it->get_to(value.system_field_strength_t);
  }
  if (auto it = j.find("relativeReceiverNoiseBandwidth"); it != j.end()) {
    it->get_to(value.relative_receiver_noise_bandwidth);
  }
  if (auto it = j.find("receiverChannels"); it != j.end()) {
    it->get_to(value.receiver_channels);
  }
  if (auto it = j.find("coilLabel"); it != j.end()) {
    it->get_to(value.coil_label);
  }
  if (auto it = j.find("institutionName"); it != j.end()) {
    it->get_to(value.institution_name);
  }
  if (auto it = j.find("stationName"); it != j.end()) {
    it->get_to(value.station_name);
  }
  if (auto it = j.find("deviceID"); it != j.end()) {
    it->get_to(value.device_id);
  }
  if (auto it = j.find("deviceSerialNumber"); it != j.end()) {
    it->get_to(value.device_serial_number);
  }
}

void to_json(ordered_json& j, mrd::ExperimentalConditionsType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.h1resonance_frequency_hz)) {
    j.push_back({"h1resonanceFrequencyHz", value.h1resonance_frequency_hz});
  }
}

void from_json(ordered_json const& j, mrd::ExperimentalConditionsType& value) {
  if (auto it = j.find("h1resonanceFrequencyHz"); it != j.end()) {
    it->get_to(value.h1resonance_frequency_hz);
  }
}

void to_json(ordered_json& j, mrd::MatrixSizeType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.x)) {
    j.push_back({"x", value.x});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.y)) {
    j.push_back({"y", value.y});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.z)) {
    j.push_back({"z", value.z});
  }
}

void from_json(ordered_json const& j, mrd::MatrixSizeType& value) {
  if (auto it = j.find("x"); it != j.end()) {
    it->get_to(value.x);
  }
  if (auto it = j.find("y"); it != j.end()) {
    it->get_to(value.y);
  }
  if (auto it = j.find("z"); it != j.end()) {
    it->get_to(value.z);
  }
}

void to_json(ordered_json& j, mrd::FieldOfViewMm const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.x)) {
    j.push_back({"x", value.x});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.y)) {
    j.push_back({"y", value.y});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.z)) {
    j.push_back({"z", value.z});
  }
}

void from_json(ordered_json const& j, mrd::FieldOfViewMm& value) {
  if (auto it = j.find("x"); it != j.end()) {
    it->get_to(value.x);
  }
  if (auto it = j.find("y"); it != j.end()) {
    it->get_to(value.y);
  }
  if (auto it = j.find("z"); it != j.end()) {
    it->get_to(value.z);
  }
}

void to_json(ordered_json& j, mrd::EncodingSpaceType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.matrix_size)) {
    j.push_back({"matrixSize", value.matrix_size});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.field_of_view_mm)) {
    j.push_back({"fieldOfViewMm", value.field_of_view_mm});
  }
}

void from_json(ordered_json const& j, mrd::EncodingSpaceType& value) {
  if (auto it = j.find("matrixSize"); it != j.end()) {
    it->get_to(value.matrix_size);
  }
  if (auto it = j.find("fieldOfViewMm"); it != j.end()) {
    it->get_to(value.field_of_view_mm);
  }
}

void to_json(ordered_json& j, mrd::LimitType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.minimum)) {
    j.push_back({"minimum", value.minimum});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.maximum)) {
    j.push_back({"maximum", value.maximum});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.center)) {
    j.push_back({"center", value.center});
  }
}

void from_json(ordered_json const& j, mrd::LimitType& value) {
  if (auto it = j.find("minimum"); it != j.end()) {
    it->get_to(value.minimum);
  }
  if (auto it = j.find("maximum"); it != j.end()) {
    it->get_to(value.maximum);
  }
  if (auto it = j.find("center"); it != j.end()) {
    it->get_to(value.center);
  }
}

void to_json(ordered_json& j, mrd::EncodingLimitsType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_0)) {
    j.push_back({"kspaceEncodingStep0", value.kspace_encoding_step_0});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_1)) {
    j.push_back({"kspaceEncodingStep1", value.kspace_encoding_step_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_2)) {
    j.push_back({"kspaceEncodingStep2", value.kspace_encoding_step_2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.average)) {
    j.push_back({"average", value.average});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.slice)) {
    j.push_back({"slice", value.slice});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.contrast)) {
    j.push_back({"contrast", value.contrast});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.phase)) {
    j.push_back({"phase", value.phase});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.repetition)) {
    j.push_back({"repetition", value.repetition});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.set)) {
    j.push_back({"set", value.set});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.segment)) {
    j.push_back({"segment", value.segment});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_0)) {
    j.push_back({"user0", value.user_0});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_1)) {
    j.push_back({"user1", value.user_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_2)) {
    j.push_back({"user2", value.user_2});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_3)) {
    j.push_back({"user3", value.user_3});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_4)) {
    j.push_back({"user4", value.user_4});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_5)) {
    j.push_back({"user5", value.user_5});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_6)) {
    j.push_back({"user6", value.user_6});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_7)) {
    j.push_back({"user7", value.user_7});
  }
}

void from_json(ordered_json const& j, mrd::EncodingLimitsType& value) {
  if (auto it = j.find("kspaceEncodingStep0"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_0);
  }
  if (auto it = j.find("kspaceEncodingStep1"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_1);
  }
  if (auto it = j.find("kspaceEncodingStep2"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_2);
  }
  if (auto it = j.find("average"); it != j.end()) {
    it->get_to(value.average);
  }
  if (auto it = j.find("slice"); it != j.end()) {
    it->get_to(value.slice);
  }
  if (auto it = j.find("contrast"); it != j.end()) {
    it->get_to(value.contrast);
  }
  if (auto it = j.find("phase"); it != j.end()) {
    it->get_to(value.phase);
  }
  if (auto it = j.find("repetition"); it != j.end()) {
    it->get_to(value.repetition);
  }
  if (auto it = j.find("set"); it != j.end()) {
    it->get_to(value.set);
  }
  if (auto it = j.find("segment"); it != j.end()) {
    it->get_to(value.segment);
  }
  if (auto it = j.find("user0"); it != j.end()) {
    it->get_to(value.user_0);
  }
  if (auto it = j.find("user1"); it != j.end()) {
    it->get_to(value.user_1);
  }
  if (auto it = j.find("user2"); it != j.end()) {
    it->get_to(value.user_2);
  }
  if (auto it = j.find("user3"); it != j.end()) {
    it->get_to(value.user_3);
  }
  if (auto it = j.find("user4"); it != j.end()) {
    it->get_to(value.user_4);
  }
  if (auto it = j.find("user5"); it != j.end()) {
    it->get_to(value.user_5);
  }
  if (auto it = j.find("user6"); it != j.end()) {
    it->get_to(value.user_6);
  }
  if (auto it = j.find("user7"); it != j.end()) {
    it->get_to(value.user_7);
  }
}

namespace {
std::unordered_map<std::string, mrd::Trajectory> const __Trajectory_values = {
  {"cartesian", mrd::Trajectory::kCartesian},
  {"epi", mrd::Trajectory::kEpi},
  {"radial", mrd::Trajectory::kRadial},
  {"goldenangle", mrd::Trajectory::kGoldenangle},
  {"spiral", mrd::Trajectory::kSpiral},
  {"other", mrd::Trajectory::kOther},
};
} //namespace

void to_json(ordered_json& j, mrd::Trajectory const& value) {
  switch (value) {
    case mrd::Trajectory::kCartesian:
      j = "cartesian";
      break;
    case mrd::Trajectory::kEpi:
      j = "epi";
      break;
    case mrd::Trajectory::kRadial:
      j = "radial";
      break;
    case mrd::Trajectory::kGoldenangle:
      j = "goldenangle";
      break;
    case mrd::Trajectory::kSpiral:
      j = "spiral";
      break;
    case mrd::Trajectory::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::Trajectory>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::Trajectory& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __Trajectory_values.find(symbol); res != __Trajectory_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::Trajectory");
  }
  using underlying_type = typename std::underlying_type<mrd::Trajectory>::type;
  value = static_cast<mrd::Trajectory>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::UserParameterLongType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.value)) {
    j.push_back({"value", value.value});
  }
}

void from_json(ordered_json const& j, mrd::UserParameterLongType& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("value"); it != j.end()) {
    it->get_to(value.value);
  }
}

void to_json(ordered_json& j, mrd::UserParameterDoubleType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.value)) {
    j.push_back({"value", value.value});
  }
}

void from_json(ordered_json const& j, mrd::UserParameterDoubleType& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("value"); it != j.end()) {
    it->get_to(value.value);
  }
}

void to_json(ordered_json& j, mrd::UserParameterStringType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.value)) {
    j.push_back({"value", value.value});
  }
}

void from_json(ordered_json const& j, mrd::UserParameterStringType& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("value"); it != j.end()) {
    it->get_to(value.value);
  }
}

void to_json(ordered_json& j, mrd::TrajectoryDescriptionType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.identifier)) {
    j.push_back({"identifier", value.identifier});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_long)) {
    j.push_back({"userParameterLong", value.user_parameter_long});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_double)) {
    j.push_back({"userParameterDouble", value.user_parameter_double});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_string)) {
    j.push_back({"userParameterString", value.user_parameter_string});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.comment)) {
    j.push_back({"comment", value.comment});
  }
}

void from_json(ordered_json const& j, mrd::TrajectoryDescriptionType& value) {
  if (auto it = j.find("identifier"); it != j.end()) {
    it->get_to(value.identifier);
  }
  if (auto it = j.find("userParameterLong"); it != j.end()) {
    it->get_to(value.user_parameter_long);
  }
  if (auto it = j.find("userParameterDouble"); it != j.end()) {
    it->get_to(value.user_parameter_double);
  }
  if (auto it = j.find("userParameterString"); it != j.end()) {
    it->get_to(value.user_parameter_string);
  }
  if (auto it = j.find("comment"); it != j.end()) {
    it->get_to(value.comment);
  }
}

void to_json(ordered_json& j, mrd::AccelerationFactorType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_1)) {
    j.push_back({"kspaceEncodingStep1", value.kspace_encoding_step_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_2)) {
    j.push_back({"kspaceEncodingStep2", value.kspace_encoding_step_2});
  }
}

void from_json(ordered_json const& j, mrd::AccelerationFactorType& value) {
  if (auto it = j.find("kspaceEncodingStep1"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_1);
  }
  if (auto it = j.find("kspaceEncodingStep2"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_2);
  }
}

namespace {
std::unordered_map<std::string, mrd::CalibrationMode> const __CalibrationMode_values = {
  {"noacceleration", mrd::CalibrationMode::kNoacceleration},
  {"embedded", mrd::CalibrationMode::kEmbedded},
  {"interleaved", mrd::CalibrationMode::kInterleaved},
  {"separate", mrd::CalibrationMode::kSeparate},
  {"external", mrd::CalibrationMode::kExternal},
  {"other", mrd::CalibrationMode::kOther},
};
} //namespace

void to_json(ordered_json& j, mrd::CalibrationMode const& value) {
  switch (value) {
    case mrd::CalibrationMode::kNoacceleration:
      j = "noacceleration";
      break;
    case mrd::CalibrationMode::kEmbedded:
      j = "embedded";
      break;
    case mrd::CalibrationMode::kInterleaved:
      j = "interleaved";
      break;
    case mrd::CalibrationMode::kSeparate:
      j = "separate";
      break;
    case mrd::CalibrationMode::kExternal:
      j = "external";
      break;
    case mrd::CalibrationMode::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::CalibrationMode>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::CalibrationMode& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __CalibrationMode_values.find(symbol); res != __CalibrationMode_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::CalibrationMode");
  }
  using underlying_type = typename std::underlying_type<mrd::CalibrationMode>::type;
  value = static_cast<mrd::CalibrationMode>(j.get<underlying_type>());
}

namespace {
std::unordered_map<std::string, mrd::InterleavingDimension> const __InterleavingDimension_values = {
  {"phase", mrd::InterleavingDimension::kPhase},
  {"repetition", mrd::InterleavingDimension::kRepetition},
  {"contrast", mrd::InterleavingDimension::kContrast},
  {"average", mrd::InterleavingDimension::kAverage},
  {"other", mrd::InterleavingDimension::kOther},
};
} //namespace

void to_json(ordered_json& j, mrd::InterleavingDimension const& value) {
  switch (value) {
    case mrd::InterleavingDimension::kPhase:
      j = "phase";
      break;
    case mrd::InterleavingDimension::kRepetition:
      j = "repetition";
      break;
    case mrd::InterleavingDimension::kContrast:
      j = "contrast";
      break;
    case mrd::InterleavingDimension::kAverage:
      j = "average";
      break;
    case mrd::InterleavingDimension::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::InterleavingDimension>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::InterleavingDimension& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __InterleavingDimension_values.find(symbol); res != __InterleavingDimension_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::InterleavingDimension");
  }
  using underlying_type = typename std::underlying_type<mrd::InterleavingDimension>::type;
  value = static_cast<mrd::InterleavingDimension>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::MultibandSpacingType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.d_z)) {
    j.push_back({"dZ", value.d_z});
  }
}

void from_json(ordered_json const& j, mrd::MultibandSpacingType& value) {
  if (auto it = j.find("dZ"); it != j.end()) {
    it->get_to(value.d_z);
  }
}

namespace {
std::unordered_map<std::string, mrd::Calibration> const __Calibration_values = {
  {"separable2D", mrd::Calibration::kSeparable2D},
  {"full3D", mrd::Calibration::kFull3D},
  {"other", mrd::Calibration::kOther},
};
} //namespace

void to_json(ordered_json& j, mrd::Calibration const& value) {
  switch (value) {
    case mrd::Calibration::kSeparable2D:
      j = "separable2D";
      break;
    case mrd::Calibration::kFull3D:
      j = "full3D";
      break;
    case mrd::Calibration::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::Calibration>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::Calibration& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __Calibration_values.find(symbol); res != __Calibration_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::Calibration");
  }
  using underlying_type = typename std::underlying_type<mrd::Calibration>::type;
  value = static_cast<mrd::Calibration>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::MultibandType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.spacing)) {
    j.push_back({"spacing", value.spacing});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.delta_kz)) {
    j.push_back({"deltaKz", value.delta_kz});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.multiband_factor)) {
    j.push_back({"multibandFactor", value.multiband_factor});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.calibration)) {
    j.push_back({"calibration", value.calibration});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.calibration_encoding)) {
    j.push_back({"calibrationEncoding", value.calibration_encoding});
  }
}

void from_json(ordered_json const& j, mrd::MultibandType& value) {
  if (auto it = j.find("spacing"); it != j.end()) {
    it->get_to(value.spacing);
  }
  if (auto it = j.find("deltaKz"); it != j.end()) {
    it->get_to(value.delta_kz);
  }
  if (auto it = j.find("multibandFactor"); it != j.end()) {
    it->get_to(value.multiband_factor);
  }
  if (auto it = j.find("calibration"); it != j.end()) {
    it->get_to(value.calibration);
  }
  if (auto it = j.find("calibrationEncoding"); it != j.end()) {
    it->get_to(value.calibration_encoding);
  }
}

void to_json(ordered_json& j, mrd::ParallelImagingType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.acceleration_factor)) {
    j.push_back({"accelerationFactor", value.acceleration_factor});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.calibration_mode)) {
    j.push_back({"calibrationMode", value.calibration_mode});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.interleaving_dimension)) {
    j.push_back({"interleavingDimension", value.interleaving_dimension});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.multiband)) {
    j.push_back({"multiband", value.multiband});
  }
}

void from_json(ordered_json const& j, mrd::ParallelImagingType& value) {
  if (auto it = j.find("accelerationFactor"); it != j.end()) {
    it->get_to(value.acceleration_factor);
  }
  if (auto it = j.find("calibrationMode"); it != j.end()) {
    it->get_to(value.calibration_mode);
  }
  if (auto it = j.find("interleavingDimension"); it != j.end()) {
    it->get_to(value.interleaving_dimension);
  }
  if (auto it = j.find("multiband"); it != j.end()) {
    it->get_to(value.multiband);
  }
}

void to_json(ordered_json& j, mrd::EncodingType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.encoded_space)) {
    j.push_back({"encodedSpace", value.encoded_space});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.recon_space)) {
    j.push_back({"reconSpace", value.recon_space});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.encoding_limits)) {
    j.push_back({"encodingLimits", value.encoding_limits});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.trajectory)) {
    j.push_back({"trajectory", value.trajectory});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.trajectory_description)) {
    j.push_back({"trajectoryDescription", value.trajectory_description});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.parallel_imaging)) {
    j.push_back({"parallelImaging", value.parallel_imaging});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.echo_train_length)) {
    j.push_back({"echoTrainLength", value.echo_train_length});
  }
}

void from_json(ordered_json const& j, mrd::EncodingType& value) {
  if (auto it = j.find("encodedSpace"); it != j.end()) {
    it->get_to(value.encoded_space);
  }
  if (auto it = j.find("reconSpace"); it != j.end()) {
    it->get_to(value.recon_space);
  }
  if (auto it = j.find("encodingLimits"); it != j.end()) {
    it->get_to(value.encoding_limits);
  }
  if (auto it = j.find("trajectory"); it != j.end()) {
    it->get_to(value.trajectory);
  }
  if (auto it = j.find("trajectoryDescription"); it != j.end()) {
    it->get_to(value.trajectory_description);
  }
  if (auto it = j.find("parallelImaging"); it != j.end()) {
    it->get_to(value.parallel_imaging);
  }
  if (auto it = j.find("echoTrainLength"); it != j.end()) {
    it->get_to(value.echo_train_length);
  }
}

namespace {
std::unordered_map<std::string, mrd::DiffusionDimension> const __DiffusionDimension_values = {
  {"average", mrd::DiffusionDimension::kAverage},
  {"contrast", mrd::DiffusionDimension::kContrast},
  {"phase", mrd::DiffusionDimension::kPhase},
  {"repetition", mrd::DiffusionDimension::kRepetition},
  {"set", mrd::DiffusionDimension::kSet},
  {"segment", mrd::DiffusionDimension::kSegment},
  {"user0", mrd::DiffusionDimension::kUser0},
  {"user1", mrd::DiffusionDimension::kUser1},
  {"user2", mrd::DiffusionDimension::kUser2},
  {"user3", mrd::DiffusionDimension::kUser3},
  {"user4", mrd::DiffusionDimension::kUser4},
  {"user5", mrd::DiffusionDimension::kUser5},
  {"user6", mrd::DiffusionDimension::kUser6},
  {"user7", mrd::DiffusionDimension::kUser7},
};
} //namespace

void to_json(ordered_json& j, mrd::DiffusionDimension const& value) {
  switch (value) {
    case mrd::DiffusionDimension::kAverage:
      j = "average";
      break;
    case mrd::DiffusionDimension::kContrast:
      j = "contrast";
      break;
    case mrd::DiffusionDimension::kPhase:
      j = "phase";
      break;
    case mrd::DiffusionDimension::kRepetition:
      j = "repetition";
      break;
    case mrd::DiffusionDimension::kSet:
      j = "set";
      break;
    case mrd::DiffusionDimension::kSegment:
      j = "segment";
      break;
    case mrd::DiffusionDimension::kUser0:
      j = "user0";
      break;
    case mrd::DiffusionDimension::kUser1:
      j = "user1";
      break;
    case mrd::DiffusionDimension::kUser2:
      j = "user2";
      break;
    case mrd::DiffusionDimension::kUser3:
      j = "user3";
      break;
    case mrd::DiffusionDimension::kUser4:
      j = "user4";
      break;
    case mrd::DiffusionDimension::kUser5:
      j = "user5";
      break;
    case mrd::DiffusionDimension::kUser6:
      j = "user6";
      break;
    case mrd::DiffusionDimension::kUser7:
      j = "user7";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::DiffusionDimension>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::DiffusionDimension& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __DiffusionDimension_values.find(symbol); res != __DiffusionDimension_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::DiffusionDimension");
  }
  using underlying_type = typename std::underlying_type<mrd::DiffusionDimension>::type;
  value = static_cast<mrd::DiffusionDimension>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::GradientDirectionType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.rl)) {
    j.push_back({"rl", value.rl});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ap)) {
    j.push_back({"ap", value.ap});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.fh)) {
    j.push_back({"fh", value.fh});
  }
}

void from_json(ordered_json const& j, mrd::GradientDirectionType& value) {
  if (auto it = j.find("rl"); it != j.end()) {
    it->get_to(value.rl);
  }
  if (auto it = j.find("ap"); it != j.end()) {
    it->get_to(value.ap);
  }
  if (auto it = j.find("fh"); it != j.end()) {
    it->get_to(value.fh);
  }
}

void to_json(ordered_json& j, mrd::DiffusionType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.gradient_direction)) {
    j.push_back({"gradientDirection", value.gradient_direction});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.bvalue)) {
    j.push_back({"bvalue", value.bvalue});
  }
}

void from_json(ordered_json const& j, mrd::DiffusionType& value) {
  if (auto it = j.find("gradientDirection"); it != j.end()) {
    it->get_to(value.gradient_direction);
  }
  if (auto it = j.find("bvalue"); it != j.end()) {
    it->get_to(value.bvalue);
  }
}

void to_json(ordered_json& j, mrd::SequenceParametersType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.t_r)) {
    j.push_back({"tR", value.t_r});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.t_e)) {
    j.push_back({"tE", value.t_e});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.t_i)) {
    j.push_back({"tI", value.t_i});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flip_angle_deg)) {
    j.push_back({"flipAngleDeg", value.flip_angle_deg});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sequence_type)) {
    j.push_back({"sequenceType", value.sequence_type});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.echo_spacing)) {
    j.push_back({"echoSpacing", value.echo_spacing});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.diffusion_dimension)) {
    j.push_back({"diffusionDimension", value.diffusion_dimension});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.diffusion)) {
    j.push_back({"diffusion", value.diffusion});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.diffusion_scheme)) {
    j.push_back({"diffusionScheme", value.diffusion_scheme});
  }
}

void from_json(ordered_json const& j, mrd::SequenceParametersType& value) {
  if (auto it = j.find("tR"); it != j.end()) {
    it->get_to(value.t_r);
  }
  if (auto it = j.find("tE"); it != j.end()) {
    it->get_to(value.t_e);
  }
  if (auto it = j.find("tI"); it != j.end()) {
    it->get_to(value.t_i);
  }
  if (auto it = j.find("flipAngleDeg"); it != j.end()) {
    it->get_to(value.flip_angle_deg);
  }
  if (auto it = j.find("sequenceType"); it != j.end()) {
    it->get_to(value.sequence_type);
  }
  if (auto it = j.find("echoSpacing"); it != j.end()) {
    it->get_to(value.echo_spacing);
  }
  if (auto it = j.find("diffusionDimension"); it != j.end()) {
    it->get_to(value.diffusion_dimension);
  }
  if (auto it = j.find("diffusion"); it != j.end()) {
    it->get_to(value.diffusion);
  }
  if (auto it = j.find("diffusionScheme"); it != j.end()) {
    it->get_to(value.diffusion_scheme);
  }
}

void to_json(ordered_json& j, mrd::UserParameterBase64Type const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.value)) {
    j.push_back({"value", value.value});
  }
}

void from_json(ordered_json const& j, mrd::UserParameterBase64Type& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("value"); it != j.end()) {
    it->get_to(value.value);
  }
}

void to_json(ordered_json& j, mrd::UserParametersType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_long)) {
    j.push_back({"userParameterLong", value.user_parameter_long});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_double)) {
    j.push_back({"userParameterDouble", value.user_parameter_double});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_string)) {
    j.push_back({"userParameterString", value.user_parameter_string});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameter_base64)) {
    j.push_back({"userParameterBase64", value.user_parameter_base64});
  }
}

void from_json(ordered_json const& j, mrd::UserParametersType& value) {
  if (auto it = j.find("userParameterLong"); it != j.end()) {
    it->get_to(value.user_parameter_long);
  }
  if (auto it = j.find("userParameterDouble"); it != j.end()) {
    it->get_to(value.user_parameter_double);
  }
  if (auto it = j.find("userParameterString"); it != j.end()) {
    it->get_to(value.user_parameter_string);
  }
  if (auto it = j.find("userParameterBase64"); it != j.end()) {
    it->get_to(value.user_parameter_base64);
  }
}

namespace {
std::unordered_map<std::string, mrd::WaveformType> const __WaveformType_values = {
  {"ecg", mrd::WaveformType::kEcg},
  {"pulse", mrd::WaveformType::kPulse},
  {"respiratory", mrd::WaveformType::kRespiratory},
  {"trigger", mrd::WaveformType::kTrigger},
  {"gradientwaveform", mrd::WaveformType::kGradientwaveform},
  {"other", mrd::WaveformType::kOther},
};
} //namespace

void to_json(ordered_json& j, mrd::WaveformType const& value) {
  switch (value) {
    case mrd::WaveformType::kEcg:
      j = "ecg";
      break;
    case mrd::WaveformType::kPulse:
      j = "pulse";
      break;
    case mrd::WaveformType::kRespiratory:
      j = "respiratory";
      break;
    case mrd::WaveformType::kTrigger:
      j = "trigger";
      break;
    case mrd::WaveformType::kGradientwaveform:
      j = "gradientwaveform";
      break;
    case mrd::WaveformType::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::WaveformType>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::WaveformType& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __WaveformType_values.find(symbol); res != __WaveformType_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::WaveformType");
  }
  using underlying_type = typename std::underlying_type<mrd::WaveformType>::type;
  value = static_cast<mrd::WaveformType>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::WaveformInformationType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.waveform_name)) {
    j.push_back({"waveformName", value.waveform_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.waveform_type)) {
    j.push_back({"waveformType", value.waveform_type});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameters)) {
    j.push_back({"userParameters", value.user_parameters});
  }
}

void from_json(ordered_json const& j, mrd::WaveformInformationType& value) {
  if (auto it = j.find("waveformName"); it != j.end()) {
    it->get_to(value.waveform_name);
  }
  if (auto it = j.find("waveformType"); it != j.end()) {
    it->get_to(value.waveform_type);
  }
  if (auto it = j.find("userParameters"); it != j.end()) {
    it->get_to(value.user_parameters);
  }
}

void to_json(ordered_json& j, mrd::Header const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.version)) {
    j.push_back({"version", value.version});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.subject_information)) {
    j.push_back({"subjectInformation", value.subject_information});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.study_information)) {
    j.push_back({"studyInformation", value.study_information});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_information)) {
    j.push_back({"measurementInformation", value.measurement_information});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.acquisition_system_information)) {
    j.push_back({"acquisitionSystemInformation", value.acquisition_system_information});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.experimental_conditions)) {
    j.push_back({"experimentalConditions", value.experimental_conditions});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.encoding)) {
    j.push_back({"encoding", value.encoding});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sequence_parameters)) {
    j.push_back({"sequenceParameters", value.sequence_parameters});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_parameters)) {
    j.push_back({"userParameters", value.user_parameters});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.waveform_information)) {
    j.push_back({"waveformInformation", value.waveform_information});
  }
}

void from_json(ordered_json const& j, mrd::Header& value) {
  if (auto it = j.find("version"); it != j.end()) {
    it->get_to(value.version);
  }
  if (auto it = j.find("subjectInformation"); it != j.end()) {
    it->get_to(value.subject_information);
  }
  if (auto it = j.find("studyInformation"); it != j.end()) {
    it->get_to(value.study_information);
  }
  if (auto it = j.find("measurementInformation"); it != j.end()) {
    it->get_to(value.measurement_information);
  }
  if (auto it = j.find("acquisitionSystemInformation"); it != j.end()) {
    it->get_to(value.acquisition_system_information);
  }
  if (auto it = j.find("experimentalConditions"); it != j.end()) {
    it->get_to(value.experimental_conditions);
  }
  if (auto it = j.find("encoding"); it != j.end()) {
    it->get_to(value.encoding);
  }
  if (auto it = j.find("sequenceParameters"); it != j.end()) {
    it->get_to(value.sequence_parameters);
  }
  if (auto it = j.find("userParameters"); it != j.end()) {
    it->get_to(value.user_parameters);
  }
  if (auto it = j.find("waveformInformation"); it != j.end()) {
    it->get_to(value.waveform_information);
  }
}

namespace {
std::unordered_map<std::string, mrd::ImageFlags> const __ImageFlags_values = {
  {"isNavigationData", mrd::ImageFlags::kIsNavigationData},
  {"firstInAverage", mrd::ImageFlags::kFirstInAverage},
  {"lastInAverage", mrd::ImageFlags::kLastInAverage},
  {"firstInSlice", mrd::ImageFlags::kFirstInSlice},
  {"lastInSlice", mrd::ImageFlags::kLastInSlice},
  {"firstInContrast", mrd::ImageFlags::kFirstInContrast},
  {"lastInContrast", mrd::ImageFlags::kLastInContrast},
  {"firstInPhase", mrd::ImageFlags::kFirstInPhase},
  {"lastInPhase", mrd::ImageFlags::kLastInPhase},
  {"firstInRepetition", mrd::ImageFlags::kFirstInRepetition},
  {"lastInRepetition", mrd::ImageFlags::kLastInRepetition},
  {"firstInSet", mrd::ImageFlags::kFirstInSet},
  {"lastInSet", mrd::ImageFlags::kLastInSet},
};
} //namespace

void to_json(ordered_json& j, mrd::ImageFlags const& value) {
  auto arr = ordered_json::array();
  if (value == 0) {
    j = arr;
    return;
  }
  auto remaining = value;
  if (remaining.HasFlags(mrd::ImageFlags::kIsNavigationData)) {
    remaining.UnsetFlags(mrd::ImageFlags::kIsNavigationData);
    arr.push_back("isNavigationData");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kFirstInAverage)) {
    remaining.UnsetFlags(mrd::ImageFlags::kFirstInAverage);
    arr.push_back("firstInAverage");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kLastInAverage)) {
    remaining.UnsetFlags(mrd::ImageFlags::kLastInAverage);
    arr.push_back("lastInAverage");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kFirstInSlice)) {
    remaining.UnsetFlags(mrd::ImageFlags::kFirstInSlice);
    arr.push_back("firstInSlice");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kLastInSlice)) {
    remaining.UnsetFlags(mrd::ImageFlags::kLastInSlice);
    arr.push_back("lastInSlice");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kFirstInContrast)) {
    remaining.UnsetFlags(mrd::ImageFlags::kFirstInContrast);
    arr.push_back("firstInContrast");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kLastInContrast)) {
    remaining.UnsetFlags(mrd::ImageFlags::kLastInContrast);
    arr.push_back("lastInContrast");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kFirstInPhase)) {
    remaining.UnsetFlags(mrd::ImageFlags::kFirstInPhase);
    arr.push_back("firstInPhase");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kLastInPhase)) {
    remaining.UnsetFlags(mrd::ImageFlags::kLastInPhase);
    arr.push_back("lastInPhase");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kFirstInRepetition)) {
    remaining.UnsetFlags(mrd::ImageFlags::kFirstInRepetition);
    arr.push_back("firstInRepetition");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kLastInRepetition)) {
    remaining.UnsetFlags(mrd::ImageFlags::kLastInRepetition);
    arr.push_back("lastInRepetition");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kFirstInSet)) {
    remaining.UnsetFlags(mrd::ImageFlags::kFirstInSet);
    arr.push_back("firstInSet");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  if (remaining.HasFlags(mrd::ImageFlags::kLastInSet)) {
    remaining.UnsetFlags(mrd::ImageFlags::kLastInSet);
    arr.push_back("lastInSet");
    if (remaining == 0) {
      j = arr;
      return;
    }
  }
  j = value.Value();
}

void from_json(ordered_json const& j, mrd::ImageFlags& value) {
  if (j.is_number()) {
    using underlying_type = typename mrd::ImageFlags::value_type;
    value = j.get<underlying_type>();
    return;
  }
  std::vector<std::string> arr = j;
  value = {};
  for (auto const& item : arr) {
    if (auto res = __ImageFlags_values.find(item); res != __ImageFlags_values.end()) {
      value |= res->second;
      continue;
    }
    throw std::runtime_error("Invalid enum value '" + item + "' for enum mrd::ImageFlags");
  }
}

namespace {
std::unordered_map<std::string, mrd::ImageType> const __ImageType_values = {
  {"magnitude", mrd::ImageType::kMagnitude},
  {"phase", mrd::ImageType::kPhase},
  {"real", mrd::ImageType::kReal},
  {"imag", mrd::ImageType::kImag},
  {"complex", mrd::ImageType::kComplex},
};
} //namespace

void to_json(ordered_json& j, mrd::ImageType const& value) {
  switch (value) {
    case mrd::ImageType::kMagnitude:
      j = "magnitude";
      break;
    case mrd::ImageType::kPhase:
      j = "phase";
      break;
    case mrd::ImageType::kReal:
      j = "real";
      break;
    case mrd::ImageType::kImag:
      j = "imag";
      break;
    case mrd::ImageType::kComplex:
      j = "complex";
      break;
    default:
      using underlying_type = typename std::underlying_type<mrd::ImageType>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, mrd::ImageType& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __ImageType_values.find(symbol); res != __ImageType_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum mrd::ImageType");
  }
  using underlying_type = typename std::underlying_type<mrd::ImageType>::type;
  value = static_cast<mrd::ImageType>(j.get<underlying_type>());
}

void to_json(ordered_json& j, mrd::ImageHeader const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flags)) {
    j.push_back({"flags", value.flags});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_uid)) {
    j.push_back({"measurementUid", value.measurement_uid});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.field_of_view)) {
    j.push_back({"fieldOfView", value.field_of_view});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.position)) {
    j.push_back({"position", value.position});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.col_dir)) {
    j.push_back({"colDir", value.col_dir});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.line_dir)) {
    j.push_back({"lineDir", value.line_dir});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.slice_dir)) {
    j.push_back({"sliceDir", value.slice_dir});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.patient_table_position)) {
    j.push_back({"patientTablePosition", value.patient_table_position});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.average)) {
    j.push_back({"average", value.average});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.slice)) {
    j.push_back({"slice", value.slice});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.contrast)) {
    j.push_back({"contrast", value.contrast});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.phase)) {
    j.push_back({"phase", value.phase});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.repetition)) {
    j.push_back({"repetition", value.repetition});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.set)) {
    j.push_back({"set", value.set});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.acquisition_time_stamp)) {
    j.push_back({"acquisitionTimeStamp", value.acquisition_time_stamp});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.physiology_time_stamp)) {
    j.push_back({"physiologyTimeStamp", value.physiology_time_stamp});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.image_type)) {
    j.push_back({"imageType", value.image_type});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.image_index)) {
    j.push_back({"imageIndex", value.image_index});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.image_series_index)) {
    j.push_back({"imageSeriesIndex", value.image_series_index});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_int)) {
    j.push_back({"userInt", value.user_int});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.user_float)) {
    j.push_back({"userFloat", value.user_float});
  }
}

void from_json(ordered_json const& j, mrd::ImageHeader& value) {
  if (auto it = j.find("flags"); it != j.end()) {
    it->get_to(value.flags);
  }
  if (auto it = j.find("measurementUid"); it != j.end()) {
    it->get_to(value.measurement_uid);
  }
  if (auto it = j.find("fieldOfView"); it != j.end()) {
    it->get_to(value.field_of_view);
  }
  if (auto it = j.find("position"); it != j.end()) {
    it->get_to(value.position);
  }
  if (auto it = j.find("colDir"); it != j.end()) {
    it->get_to(value.col_dir);
  }
  if (auto it = j.find("lineDir"); it != j.end()) {
    it->get_to(value.line_dir);
  }
  if (auto it = j.find("sliceDir"); it != j.end()) {
    it->get_to(value.slice_dir);
  }
  if (auto it = j.find("patientTablePosition"); it != j.end()) {
    it->get_to(value.patient_table_position);
  }
  if (auto it = j.find("average"); it != j.end()) {
    it->get_to(value.average);
  }
  if (auto it = j.find("slice"); it != j.end()) {
    it->get_to(value.slice);
  }
  if (auto it = j.find("contrast"); it != j.end()) {
    it->get_to(value.contrast);
  }
  if (auto it = j.find("phase"); it != j.end()) {
    it->get_to(value.phase);
  }
  if (auto it = j.find("repetition"); it != j.end()) {
    it->get_to(value.repetition);
  }
  if (auto it = j.find("set"); it != j.end()) {
    it->get_to(value.set);
  }
  if (auto it = j.find("acquisitionTimeStamp"); it != j.end()) {
    it->get_to(value.acquisition_time_stamp);
  }
  if (auto it = j.find("physiologyTimeStamp"); it != j.end()) {
    it->get_to(value.physiology_time_stamp);
  }
  if (auto it = j.find("imageType"); it != j.end()) {
    it->get_to(value.image_type);
  }
  if (auto it = j.find("imageIndex"); it != j.end()) {
    it->get_to(value.image_index);
  }
  if (auto it = j.find("imageSeriesIndex"); it != j.end()) {
    it->get_to(value.image_series_index);
  }
  if (auto it = j.find("userInt"); it != j.end()) {
    it->get_to(value.user_int);
  }
  if (auto it = j.find("userFloat"); it != j.end()) {
    it->get_to(value.user_float);
  }
}

template <typename T>
void to_json(ordered_json& j, mrd::Image<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.head)) {
    j.push_back({"head", value.head});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.meta)) {
    j.push_back({"meta", value.meta});
  }
}

template <typename T>
void from_json(ordered_json const& j, mrd::Image<T>& value) {
  if (auto it = j.find("head"); it != j.end()) {
    it->get_to(value.head);
  }
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("meta"); it != j.end()) {
    it->get_to(value.meta);
  }
}

void to_json(ordered_json& j, mrd::NoiseCovariance const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.coil_labels)) {
    j.push_back({"coilLabels", value.coil_labels});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.receiver_noise_bandwidth)) {
    j.push_back({"receiverNoiseBandwidth", value.receiver_noise_bandwidth});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.noise_dwell_time_us)) {
    j.push_back({"noiseDwellTimeUs", value.noise_dwell_time_us});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sample_count)) {
    j.push_back({"sampleCount", value.sample_count});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.matrix)) {
    j.push_back({"matrix", value.matrix});
  }
}

void from_json(ordered_json const& j, mrd::NoiseCovariance& value) {
  if (auto it = j.find("coilLabels"); it != j.end()) {
    it->get_to(value.coil_labels);
  }
  if (auto it = j.find("receiverNoiseBandwidth"); it != j.end()) {
    it->get_to(value.receiver_noise_bandwidth);
  }
  if (auto it = j.find("noiseDwellTimeUs"); it != j.end()) {
    it->get_to(value.noise_dwell_time_us);
  }
  if (auto it = j.find("sampleCount"); it != j.end()) {
    it->get_to(value.sample_count);
  }
  if (auto it = j.find("matrix"); it != j.end()) {
    it->get_to(value.matrix);
  }
}

template <typename T>
void to_json(ordered_json& j, mrd::Waveform<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.flags)) {
    j.push_back({"flags", value.flags});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.measurement_uid)) {
    j.push_back({"measurementUid", value.measurement_uid});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.scan_counter)) {
    j.push_back({"scanCounter", value.scan_counter});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.time_stamp)) {
    j.push_back({"timeStamp", value.time_stamp});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sample_time_us)) {
    j.push_back({"sampleTimeUs", value.sample_time_us});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.waveform_id)) {
    j.push_back({"waveformId", value.waveform_id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
}

template <typename T>
void from_json(ordered_json const& j, mrd::Waveform<T>& value) {
  if (auto it = j.find("flags"); it != j.end()) {
    it->get_to(value.flags);
  }
  if (auto it = j.find("measurementUid"); it != j.end()) {
    it->get_to(value.measurement_uid);
  }
  if (auto it = j.find("scanCounter"); it != j.end()) {
    it->get_to(value.scan_counter);
  }
  if (auto it = j.find("timeStamp"); it != j.end()) {
    it->get_to(value.time_stamp);
  }
  if (auto it = j.find("sampleTimeUs"); it != j.end()) {
    it->get_to(value.sample_time_us);
  }
  if (auto it = j.find("waveformId"); it != j.end()) {
    it->get_to(value.waveform_id);
  }
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
}

void to_json(ordered_json& j, mrd::AcquisitionBucket const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ref)) {
    j.push_back({"ref", value.ref});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.datastats)) {
    j.push_back({"datastats", value.datastats});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.refstats)) {
    j.push_back({"refstats", value.refstats});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.waveforms)) {
    j.push_back({"waveforms", value.waveforms});
  }
}

void from_json(ordered_json const& j, mrd::AcquisitionBucket& value) {
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("ref"); it != j.end()) {
    it->get_to(value.ref);
  }
  if (auto it = j.find("datastats"); it != j.end()) {
    it->get_to(value.datastats);
  }
  if (auto it = j.find("refstats"); it != j.end()) {
    it->get_to(value.refstats);
  }
  if (auto it = j.find("waveforms"); it != j.end()) {
    it->get_to(value.waveforms);
  }
}

void to_json(ordered_json& j, mrd::SamplingLimits const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_0)) {
    j.push_back({"kspaceEncodingStep0", value.kspace_encoding_step_0});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_1)) {
    j.push_back({"kspaceEncodingStep1", value.kspace_encoding_step_1});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.kspace_encoding_step_2)) {
    j.push_back({"kspaceEncodingStep2", value.kspace_encoding_step_2});
  }
}

void from_json(ordered_json const& j, mrd::SamplingLimits& value) {
  if (auto it = j.find("kspaceEncodingStep0"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_0);
  }
  if (auto it = j.find("kspaceEncodingStep1"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_1);
  }
  if (auto it = j.find("kspaceEncodingStep2"); it != j.end()) {
    it->get_to(value.kspace_encoding_step_2);
  }
}

void to_json(ordered_json& j, mrd::SamplingDescription const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.encoded_fov)) {
    j.push_back({"encodedFOV", value.encoded_fov});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.recon_fov)) {
    j.push_back({"reconFOV", value.recon_fov});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.encoded_matrix)) {
    j.push_back({"encodedMatrix", value.encoded_matrix});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.recon_matrix)) {
    j.push_back({"reconMatrix", value.recon_matrix});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sampling_limits)) {
    j.push_back({"samplingLimits", value.sampling_limits});
  }
}

void from_json(ordered_json const& j, mrd::SamplingDescription& value) {
  if (auto it = j.find("encodedFOV"); it != j.end()) {
    it->get_to(value.encoded_fov);
  }
  if (auto it = j.find("reconFOV"); it != j.end()) {
    it->get_to(value.recon_fov);
  }
  if (auto it = j.find("encodedMatrix"); it != j.end()) {
    it->get_to(value.encoded_matrix);
  }
  if (auto it = j.find("reconMatrix"); it != j.end()) {
    it->get_to(value.recon_matrix);
  }
  if (auto it = j.find("samplingLimits"); it != j.end()) {
    it->get_to(value.sampling_limits);
  }
}

void to_json(ordered_json& j, mrd::ReconBuffer const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.trajectory)) {
    j.push_back({"trajectory", value.trajectory});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.density)) {
    j.push_back({"density", value.density});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.headers)) {
    j.push_back({"headers", value.headers});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.sampling)) {
    j.push_back({"sampling", value.sampling});
  }
}

void from_json(ordered_json const& j, mrd::ReconBuffer& value) {
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("trajectory"); it != j.end()) {
    it->get_to(value.trajectory);
  }
  if (auto it = j.find("density"); it != j.end()) {
    it->get_to(value.density);
  }
  if (auto it = j.find("headers"); it != j.end()) {
    it->get_to(value.headers);
  }
  if (auto it = j.find("sampling"); it != j.end()) {
    it->get_to(value.sampling);
  }
}

void to_json(ordered_json& j, mrd::ReconAssembly const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ref)) {
    j.push_back({"ref", value.ref});
  }
}

void from_json(ordered_json const& j, mrd::ReconAssembly& value) {
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("ref"); it != j.end()) {
    it->get_to(value.ref);
  }
}

void to_json(ordered_json& j, mrd::ReconData const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.buffers)) {
    j.push_back({"buffers", value.buffers});
  }
}

void from_json(ordered_json const& j, mrd::ReconData& value) {
  if (auto it = j.find("buffers"); it != j.end()) {
    it->get_to(value.buffers);
  }
}

void to_json(ordered_json& j, mrd::ImageArray const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.data)) {
    j.push_back({"data", value.data});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.headers)) {
    j.push_back({"headers", value.headers});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.meta)) {
    j.push_back({"meta", value.meta});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.waveforms)) {
    j.push_back({"waveforms", value.waveforms});
  }
}

void from_json(ordered_json const& j, mrd::ImageArray& value) {
  if (auto it = j.find("data"); it != j.end()) {
    it->get_to(value.data);
  }
  if (auto it = j.find("headers"); it != j.end()) {
    it->get_to(value.headers);
  }
  if (auto it = j.find("meta"); it != j.end()) {
    it->get_to(value.meta);
  }
  if (auto it = j.find("waveforms"); it != j.end()) {
    it->get_to(value.waveforms);
  }
}

} // namespace mrd

namespace mrd::ndjson {
void MrdWriter::WriteHeaderImpl(std::optional<mrd::Header> const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "header", json_value);}

void MrdWriter::WriteDataImpl(mrd::StreamItem const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "data", json_value);}

void MrdWriter::Flush() {
  stream_.flush();
}

void MrdWriter::CloseImpl() {
  stream_.flush();
}

void MrdReader::ReadHeaderImpl(std::optional<mrd::Header>& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "header", true, unused_step_, value);
}

bool MrdReader::ReadDataImpl(mrd::StreamItem& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "data", false, unused_step_, value);
}

void MrdReader::CloseImpl() {
  VerifyFinished();
}

void MrdNoiseCovarianceWriter::WriteNoiseCovarianceImpl(mrd::NoiseCovariance const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "noiseCovariance", json_value);}

void MrdNoiseCovarianceWriter::Flush() {
  stream_.flush();
}

void MrdNoiseCovarianceWriter::CloseImpl() {
  stream_.flush();
}

void MrdNoiseCovarianceReader::ReadNoiseCovarianceImpl(mrd::NoiseCovariance& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "noiseCovariance", true, unused_step_, value);
}

void MrdNoiseCovarianceReader::CloseImpl() {
  VerifyFinished();
}

} // namespace mrd::ndjson

