// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include <array>
#include <complex>
#include <optional>
#include <unordered_map>
#include <variant>
#include <vector>

#include "yardl/yardl.h"

namespace mrd {
struct AcquisitionFlags : yardl::BaseFlags<uint64_t, AcquisitionFlags> {
  using BaseFlags::BaseFlags;
  static const AcquisitionFlags kFirstInEncodeStep1;
  static const AcquisitionFlags kLastInEncodeStep1;
  static const AcquisitionFlags kFirstInEncodeStep2;
  static const AcquisitionFlags kLastInEncodeStep2;
  static const AcquisitionFlags kFirstInAverage;
  static const AcquisitionFlags kLastInAverage;
  static const AcquisitionFlags kFirstInSlice;
  static const AcquisitionFlags kLastInSlice;
  static const AcquisitionFlags kFirstInContrast;
  static const AcquisitionFlags kLastInContrast;
  static const AcquisitionFlags kFirstInPhase;
  static const AcquisitionFlags kLastInPhase;
  static const AcquisitionFlags kFirstInRepetition;
  static const AcquisitionFlags kLastInRepetition;
  static const AcquisitionFlags kFirstInSet;
  static const AcquisitionFlags kLastInSet;
  static const AcquisitionFlags kFirstInSegment;
  static const AcquisitionFlags kLastInSegment;
  static const AcquisitionFlags kIsNoiseMeasurement;
  static const AcquisitionFlags kIsParallelCalibration;
  static const AcquisitionFlags kIsParallelCalibrationAndImaging;
  static const AcquisitionFlags kIsReverse;
  static const AcquisitionFlags kIsNavigationData;
  static const AcquisitionFlags kIsPhasecorrData;
  static const AcquisitionFlags kLastInMeasurement;
  static const AcquisitionFlags kIsHpfeedbackData;
  static const AcquisitionFlags kIsDummyscanData;
  static const AcquisitionFlags kIsRtfeedbackData;
  static const AcquisitionFlags kIsSurfacecoilcorrectionscanData;
  static const AcquisitionFlags kIsPhaseStabilizationReference;
  static const AcquisitionFlags kIsPhaseStabilization;
};

struct EncodingCounters {
  // Phase encoding line
  std::optional<uint32_t> kspace_encode_step_1{};
  // Partition encoding
  std::optional<uint32_t> kspace_encode_step_2{};
  // Signal average
  std::optional<uint32_t> average{};
  // Slice number (multi-slice 2D)
  std::optional<uint32_t> slice{};
  // Echo number in multi-echo
  std::optional<uint32_t> contrast{};
  // Cardiac phase
  std::optional<uint32_t> phase{};
  // Counter in repeated/dynamic acquisitions
  std::optional<uint32_t> repetition{};
  // Sets of different preparation, e.g. flow encoding, diffusion weighting
  std::optional<uint32_t> set{};
  // Counter for segmented acquisitions
  std::optional<uint32_t> segment{};
  // User-defined counters
  std::vector<uint32_t> user{};

  bool operator==(const EncodingCounters& other) const {
    return kspace_encode_step_1 == other.kspace_encode_step_1 &&
      kspace_encode_step_2 == other.kspace_encode_step_2 &&
      average == other.average &&
      slice == other.slice &&
      contrast == other.contrast &&
      phase == other.phase &&
      repetition == other.repetition &&
      set == other.set &&
      segment == other.segment &&
      user == other.user;
  }

  bool operator!=(const EncodingCounters& other) const {
    return !(*this == other);
  }
};

using AcquisitionData = yardl::NDArray<std::complex<float>, 2>;

using TrajectoryData = yardl::NDArray<float, 2>;

struct AcquisitionHeader {
  // A bit mask of common attributes applicable to individual acquisition
  mrd::AcquisitionFlags flags{};
  // Encoding loop counters
  mrd::EncodingCounters idx{};
  // Unique ID corresponding to the readout
  uint32_t measurement_uid{};
  // Zero-indexed incrementing counter for readouts
  std::optional<uint32_t> scan_counter{};
  // Clock time stamp (e.g. milliseconds since midnight)
  std::optional<uint32_t> acquisition_time_stamp{};
  // Time stamps relative to physiological triggering
  std::vector<uint32_t> physiology_time_stamp{};
  // Channel numbers
  std::vector<uint32_t> channel_order{};
  // Number of readout samples to be discarded at the beginning
  //   (e.g. if the ADC is active during gradient events)
  std::optional<uint32_t> discard_pre{};
  // Number of readout samples to be discarded at the end
  //   (e.g. if the ADC is active during gradient events)
  std::optional<uint32_t> discard_post{};
  // Index of the readout sample corresponing to k-space center (zero indexed)
  std::optional<uint32_t> center_sample{};
  // Indexed reference to the encoding spaces enumerated in the MRD Header
  std::optional<uint32_t> encoding_space_ref{};
  // Readout bandwidth, as time between samples in microseconds
  std::optional<float> sample_time_us{};
  // Center of the excited volume, in LPS coordinates relative to isocenter in millimeters
  yardl::FixedNDArray<float, 3> position{};
  // Directional cosine of readout/frequency encoding
  yardl::FixedNDArray<float, 3> read_dir{};
  // Directional cosine of phase encoding (2D)
  yardl::FixedNDArray<float, 3> phase_dir{};
  // Directional cosine of slice normal, i.e. cross-product of read_dir and phase_dir
  yardl::FixedNDArray<float, 3> slice_dir{};
  // Offset position of the patient table, in LPS coordinates
  yardl::FixedNDArray<float, 3> patient_table_position{};
  // User-defined integer parameters
  std::vector<int32_t> user_int{};
  // User-defined float parameters
  std::vector<float> user_float{};

  bool operator==(const AcquisitionHeader& other) const {
    return flags == other.flags &&
      idx == other.idx &&
      measurement_uid == other.measurement_uid &&
      scan_counter == other.scan_counter &&
      acquisition_time_stamp == other.acquisition_time_stamp &&
      physiology_time_stamp == other.physiology_time_stamp &&
      channel_order == other.channel_order &&
      discard_pre == other.discard_pre &&
      discard_post == other.discard_post &&
      center_sample == other.center_sample &&
      encoding_space_ref == other.encoding_space_ref &&
      sample_time_us == other.sample_time_us &&
      position == other.position &&
      read_dir == other.read_dir &&
      phase_dir == other.phase_dir &&
      slice_dir == other.slice_dir &&
      patient_table_position == other.patient_table_position &&
      user_int == other.user_int &&
      user_float == other.user_float;
  }

  bool operator!=(const AcquisitionHeader& other) const {
    return !(*this == other);
  }
};

struct Acquisition {
  // Acquisition header
  mrd::AcquisitionHeader head{};
  // Raw k-space samples array
  mrd::AcquisitionData data{};
  // Trajectory array
  mrd::TrajectoryData trajectory{};

  yardl::Size Coils() const {
    return yardl::shape(data, 0);
  }

  yardl::Size Samples() const {
    return yardl::shape(data, 1);
  }

  yardl::Size ActiveChannels() const {
    return head.channel_order.size();
  }

  yardl::Size TrajectoryDimensions() const {
    return yardl::shape(trajectory, 0);
  }

  yardl::Size TrajectorySamples() const {
    return yardl::shape(trajectory, 1);
  }

  bool operator==(const Acquisition& other) const {
    return head == other.head &&
      data == other.data &&
      trajectory == other.trajectory;
  }

  bool operator!=(const Acquisition& other) const {
    return !(*this == other);
  }
};

enum class PatientGender {
  kM = 0,
  kF = 1,
  kO = 2,
};

struct SubjectInformationType {
  std::optional<std::string> patient_name{};
  std::optional<float> patient_weight_kg{};
  std::optional<float> patient_height_m{};
  std::optional<std::string> patient_id{};
  std::optional<yardl::Date> patient_birthdate{};
  std::optional<mrd::PatientGender> patient_gender{};

  bool operator==(const SubjectInformationType& other) const {
    return patient_name == other.patient_name &&
      patient_weight_kg == other.patient_weight_kg &&
      patient_height_m == other.patient_height_m &&
      patient_id == other.patient_id &&
      patient_birthdate == other.patient_birthdate &&
      patient_gender == other.patient_gender;
  }

  bool operator!=(const SubjectInformationType& other) const {
    return !(*this == other);
  }
};

struct StudyInformationType {
  std::optional<yardl::Date> study_date{};
  std::optional<yardl::Time> study_time{};
  std::optional<std::string> study_id{};
  std::optional<int64_t> accession_number{};
  std::optional<std::string> referring_physician_name{};
  std::optional<std::string> study_description{};
  std::optional<std::string> study_instance_uid{};
  std::optional<std::string> body_part_examined{};

  bool operator==(const StudyInformationType& other) const {
    return study_date == other.study_date &&
      study_time == other.study_time &&
      study_id == other.study_id &&
      accession_number == other.accession_number &&
      referring_physician_name == other.referring_physician_name &&
      study_description == other.study_description &&
      study_instance_uid == other.study_instance_uid &&
      body_part_examined == other.body_part_examined;
  }

  bool operator!=(const StudyInformationType& other) const {
    return !(*this == other);
  }
};

enum class PatientPosition {
  kHFP = 0,
  kHFS = 1,
  kHFDR = 2,
  kHFDL = 3,
  kFFP = 4,
  kFFS = 5,
  kFFDR = 6,
  kFFDL = 7,
};

struct ThreeDimensionalFloat {
  float x{};
  float y{};
  float z{};

  bool operator==(const ThreeDimensionalFloat& other) const {
    return x == other.x &&
      y == other.y &&
      z == other.z;
  }

  bool operator!=(const ThreeDimensionalFloat& other) const {
    return !(*this == other);
  }
};

struct MeasurementDependencyType {
  std::string dependency_type{};
  std::string measurement_id{};

  bool operator==(const MeasurementDependencyType& other) const {
    return dependency_type == other.dependency_type &&
      measurement_id == other.measurement_id;
  }

  bool operator!=(const MeasurementDependencyType& other) const {
    return !(*this == other);
  }
};

struct ReferencedImageSequenceType {
  std::vector<std::string> referenced_sop_instance_uid{};

  bool operator==(const ReferencedImageSequenceType& other) const {
    return referenced_sop_instance_uid == other.referenced_sop_instance_uid;
  }

  bool operator!=(const ReferencedImageSequenceType& other) const {
    return !(*this == other);
  }
};

struct MeasurementInformationType {
  std::optional<std::string> measurement_id{};
  std::optional<yardl::Date> series_date{};
  std::optional<yardl::Time> series_time{};
  mrd::PatientPosition patient_position{};
  std::optional<mrd::ThreeDimensionalFloat> relative_table_position{};
  std::optional<int64_t> initial_series_number{};
  std::optional<std::string> protocol_name{};
  std::optional<std::string> sequence_name{};
  std::optional<std::string> series_description{};
  std::vector<mrd::MeasurementDependencyType> measurement_dependency{};
  std::optional<std::string> series_instance_uid_root{};
  std::optional<std::string> frame_of_reference_uid{};
  std::optional<mrd::ReferencedImageSequenceType> referenced_image_sequence{};

  bool operator==(const MeasurementInformationType& other) const {
    return measurement_id == other.measurement_id &&
      series_date == other.series_date &&
      series_time == other.series_time &&
      patient_position == other.patient_position &&
      relative_table_position == other.relative_table_position &&
      initial_series_number == other.initial_series_number &&
      protocol_name == other.protocol_name &&
      sequence_name == other.sequence_name &&
      series_description == other.series_description &&
      measurement_dependency == other.measurement_dependency &&
      series_instance_uid_root == other.series_instance_uid_root &&
      frame_of_reference_uid == other.frame_of_reference_uid &&
      referenced_image_sequence == other.referenced_image_sequence;
  }

  bool operator!=(const MeasurementInformationType& other) const {
    return !(*this == other);
  }
};

struct CoilLabelType {
  uint32_t coil_number{};
  std::string coil_name{};

  bool operator==(const CoilLabelType& other) const {
    return coil_number == other.coil_number &&
      coil_name == other.coil_name;
  }

  bool operator!=(const CoilLabelType& other) const {
    return !(*this == other);
  }
};

struct AcquisitionSystemInformationType {
  std::optional<std::string> system_vendor{};
  std::optional<std::string> system_model{};
  std::optional<float> system_field_strength_t{};
  std::optional<float> relative_receiver_noise_bandwidth{};
  std::optional<uint32_t> receiver_channels{};
  std::vector<mrd::CoilLabelType> coil_label{};
  std::optional<std::string> institution_name{};
  std::optional<std::string> station_name{};
  std::optional<std::string> device_id{};
  std::optional<std::string> device_serial_number{};

  bool operator==(const AcquisitionSystemInformationType& other) const {
    return system_vendor == other.system_vendor &&
      system_model == other.system_model &&
      system_field_strength_t == other.system_field_strength_t &&
      relative_receiver_noise_bandwidth == other.relative_receiver_noise_bandwidth &&
      receiver_channels == other.receiver_channels &&
      coil_label == other.coil_label &&
      institution_name == other.institution_name &&
      station_name == other.station_name &&
      device_id == other.device_id &&
      device_serial_number == other.device_serial_number;
  }

  bool operator!=(const AcquisitionSystemInformationType& other) const {
    return !(*this == other);
  }
};

struct ExperimentalConditionsType {
  int64_t h1resonance_frequency_hz{};

  bool operator==(const ExperimentalConditionsType& other) const {
    return h1resonance_frequency_hz == other.h1resonance_frequency_hz;
  }

  bool operator!=(const ExperimentalConditionsType& other) const {
    return !(*this == other);
  }
};

struct MatrixSizeType {
  uint32_t x{};
  uint32_t y{};
  uint32_t z{};

  bool operator==(const MatrixSizeType& other) const {
    return x == other.x &&
      y == other.y &&
      z == other.z;
  }

  bool operator!=(const MatrixSizeType& other) const {
    return !(*this == other);
  }
};

struct FieldOfViewMm {
  float x{};
  float y{};
  float z{};

  bool operator==(const FieldOfViewMm& other) const {
    return x == other.x &&
      y == other.y &&
      z == other.z;
  }

  bool operator!=(const FieldOfViewMm& other) const {
    return !(*this == other);
  }
};

struct EncodingSpaceType {
  mrd::MatrixSizeType matrix_size{};
  mrd::FieldOfViewMm field_of_view_mm{};

  bool operator==(const EncodingSpaceType& other) const {
    return matrix_size == other.matrix_size &&
      field_of_view_mm == other.field_of_view_mm;
  }

  bool operator!=(const EncodingSpaceType& other) const {
    return !(*this == other);
  }
};

struct LimitType {
  uint32_t minimum{};
  uint32_t maximum{};
  uint32_t center{};

  bool operator==(const LimitType& other) const {
    return minimum == other.minimum &&
      maximum == other.maximum &&
      center == other.center;
  }

  bool operator!=(const LimitType& other) const {
    return !(*this == other);
  }
};

struct EncodingLimitsType {
  std::optional<mrd::LimitType> kspace_encoding_step_0{};
  std::optional<mrd::LimitType> kspace_encoding_step_1{};
  std::optional<mrd::LimitType> kspace_encoding_step_2{};
  std::optional<mrd::LimitType> average{};
  std::optional<mrd::LimitType> slice{};
  std::optional<mrd::LimitType> contrast{};
  std::optional<mrd::LimitType> phase{};
  std::optional<mrd::LimitType> repetition{};
  std::optional<mrd::LimitType> set{};
  std::optional<mrd::LimitType> segment{};
  std::optional<mrd::LimitType> user_0{};
  std::optional<mrd::LimitType> user_1{};
  std::optional<mrd::LimitType> user_2{};
  std::optional<mrd::LimitType> user_3{};
  std::optional<mrd::LimitType> user_4{};
  std::optional<mrd::LimitType> user_5{};
  std::optional<mrd::LimitType> user_6{};
  std::optional<mrd::LimitType> user_7{};

  bool operator==(const EncodingLimitsType& other) const {
    return kspace_encoding_step_0 == other.kspace_encoding_step_0 &&
      kspace_encoding_step_1 == other.kspace_encoding_step_1 &&
      kspace_encoding_step_2 == other.kspace_encoding_step_2 &&
      average == other.average &&
      slice == other.slice &&
      contrast == other.contrast &&
      phase == other.phase &&
      repetition == other.repetition &&
      set == other.set &&
      segment == other.segment &&
      user_0 == other.user_0 &&
      user_1 == other.user_1 &&
      user_2 == other.user_2 &&
      user_3 == other.user_3 &&
      user_4 == other.user_4 &&
      user_5 == other.user_5 &&
      user_6 == other.user_6 &&
      user_7 == other.user_7;
  }

  bool operator!=(const EncodingLimitsType& other) const {
    return !(*this == other);
  }
};

enum class Trajectory {
  kCartesian = 0,
  kEpi = 1,
  kRadial = 2,
  kGoldenangle = 3,
  kSpiral = 4,
  kOther = 5,
};

struct UserParameterLongType {
  std::string name{};
  int64_t value{};

  bool operator==(const UserParameterLongType& other) const {
    return name == other.name &&
      value == other.value;
  }

  bool operator!=(const UserParameterLongType& other) const {
    return !(*this == other);
  }
};

struct UserParameterDoubleType {
  std::string name{};
  double value{};

  bool operator==(const UserParameterDoubleType& other) const {
    return name == other.name &&
      value == other.value;
  }

  bool operator!=(const UserParameterDoubleType& other) const {
    return !(*this == other);
  }
};

struct UserParameterStringType {
  std::string name{};
  std::string value{};

  bool operator==(const UserParameterStringType& other) const {
    return name == other.name &&
      value == other.value;
  }

  bool operator!=(const UserParameterStringType& other) const {
    return !(*this == other);
  }
};

struct TrajectoryDescriptionType {
  std::string identifier{};
  std::vector<mrd::UserParameterLongType> user_parameter_long{};
  std::vector<mrd::UserParameterDoubleType> user_parameter_double{};
  std::vector<mrd::UserParameterStringType> user_parameter_string{};
  std::optional<std::string> comment{};

  bool operator==(const TrajectoryDescriptionType& other) const {
    return identifier == other.identifier &&
      user_parameter_long == other.user_parameter_long &&
      user_parameter_double == other.user_parameter_double &&
      user_parameter_string == other.user_parameter_string &&
      comment == other.comment;
  }

  bool operator!=(const TrajectoryDescriptionType& other) const {
    return !(*this == other);
  }
};

struct AccelerationFactorType {
  uint32_t kspace_encoding_step_1{};
  uint32_t kspace_encoding_step_2{};

  bool operator==(const AccelerationFactorType& other) const {
    return kspace_encoding_step_1 == other.kspace_encoding_step_1 &&
      kspace_encoding_step_2 == other.kspace_encoding_step_2;
  }

  bool operator!=(const AccelerationFactorType& other) const {
    return !(*this == other);
  }
};

enum class CalibrationMode {
  kNoacceleration = 0,
  kEmbedded = 1,
  kInterleaved = 2,
  kSeparate = 3,
  kExternal = 4,
  kOther = 5,
};

enum class InterleavingDimension {
  kPhase = 0,
  kRepetition = 1,
  kContrast = 2,
  kAverage = 3,
  kOther = 4,
};

struct MultibandSpacingType {
  std::vector<float> d_z{};

  bool operator==(const MultibandSpacingType& other) const {
    return d_z == other.d_z;
  }

  bool operator!=(const MultibandSpacingType& other) const {
    return !(*this == other);
  }
};

enum class Calibration {
  kSeparable2D = 0,
  kFull3D = 1,
  kOther = 2,
};

struct MultibandType {
  std::vector<mrd::MultibandSpacingType> spacing{};
  float delta_kz{};
  uint32_t multiband_factor{};
  mrd::Calibration calibration{};
  uint64_t calibration_encoding{};

  bool operator==(const MultibandType& other) const {
    return spacing == other.spacing &&
      delta_kz == other.delta_kz &&
      multiband_factor == other.multiband_factor &&
      calibration == other.calibration &&
      calibration_encoding == other.calibration_encoding;
  }

  bool operator!=(const MultibandType& other) const {
    return !(*this == other);
  }
};

struct ParallelImagingType {
  mrd::AccelerationFactorType acceleration_factor{};
  std::optional<mrd::CalibrationMode> calibration_mode{};
  std::optional<mrd::InterleavingDimension> interleaving_dimension{};
  std::optional<mrd::MultibandType> multiband{};

  bool operator==(const ParallelImagingType& other) const {
    return acceleration_factor == other.acceleration_factor &&
      calibration_mode == other.calibration_mode &&
      interleaving_dimension == other.interleaving_dimension &&
      multiband == other.multiband;
  }

  bool operator!=(const ParallelImagingType& other) const {
    return !(*this == other);
  }
};

struct EncodingType {
  mrd::EncodingSpaceType encoded_space{};
  mrd::EncodingSpaceType recon_space{};
  mrd::EncodingLimitsType encoding_limits{};
  mrd::Trajectory trajectory{};
  std::optional<mrd::TrajectoryDescriptionType> trajectory_description{};
  std::optional<mrd::ParallelImagingType> parallel_imaging{};
  std::optional<int64_t> echo_train_length{};

  bool operator==(const EncodingType& other) const {
    return encoded_space == other.encoded_space &&
      recon_space == other.recon_space &&
      encoding_limits == other.encoding_limits &&
      trajectory == other.trajectory &&
      trajectory_description == other.trajectory_description &&
      parallel_imaging == other.parallel_imaging &&
      echo_train_length == other.echo_train_length;
  }

  bool operator!=(const EncodingType& other) const {
    return !(*this == other);
  }
};

enum class DiffusionDimension {
  kAverage = 0,
  kContrast = 1,
  kPhase = 2,
  kRepetition = 3,
  kSet = 4,
  kSegment = 5,
  kUser0 = 6,
  kUser1 = 7,
  kUser2 = 8,
  kUser3 = 9,
  kUser4 = 10,
  kUser5 = 11,
  kUser6 = 12,
  kUser7 = 13,
};

struct GradientDirectionType {
  float rl{};
  float ap{};
  float fh{};

  bool operator==(const GradientDirectionType& other) const {
    return rl == other.rl &&
      ap == other.ap &&
      fh == other.fh;
  }

  bool operator!=(const GradientDirectionType& other) const {
    return !(*this == other);
  }
};

struct DiffusionType {
  mrd::GradientDirectionType gradient_direction{};
  float bvalue{};

  bool operator==(const DiffusionType& other) const {
    return gradient_direction == other.gradient_direction &&
      bvalue == other.bvalue;
  }

  bool operator!=(const DiffusionType& other) const {
    return !(*this == other);
  }
};

struct SequenceParametersType {
  std::vector<float> t_r{};
  std::vector<float> t_e{};
  std::vector<float> t_i{};
  std::vector<float> flip_angle_deg{};
  std::optional<std::string> sequence_type{};
  std::vector<float> echo_spacing{};
  std::optional<mrd::DiffusionDimension> diffusion_dimension{};
  std::vector<mrd::DiffusionType> diffusion{};
  std::optional<std::string> diffusion_scheme{};

  bool operator==(const SequenceParametersType& other) const {
    return t_r == other.t_r &&
      t_e == other.t_e &&
      t_i == other.t_i &&
      flip_angle_deg == other.flip_angle_deg &&
      sequence_type == other.sequence_type &&
      echo_spacing == other.echo_spacing &&
      diffusion_dimension == other.diffusion_dimension &&
      diffusion == other.diffusion &&
      diffusion_scheme == other.diffusion_scheme;
  }

  bool operator!=(const SequenceParametersType& other) const {
    return !(*this == other);
  }
};

struct UserParameterBase64Type {
  std::string name{};
  std::string value{};

  bool operator==(const UserParameterBase64Type& other) const {
    return name == other.name &&
      value == other.value;
  }

  bool operator!=(const UserParameterBase64Type& other) const {
    return !(*this == other);
  }
};

struct UserParametersType {
  std::vector<mrd::UserParameterLongType> user_parameter_long{};
  std::vector<mrd::UserParameterDoubleType> user_parameter_double{};
  std::vector<mrd::UserParameterStringType> user_parameter_string{};
  std::vector<mrd::UserParameterBase64Type> user_parameter_base64{};

  bool operator==(const UserParametersType& other) const {
    return user_parameter_long == other.user_parameter_long &&
      user_parameter_double == other.user_parameter_double &&
      user_parameter_string == other.user_parameter_string &&
      user_parameter_base64 == other.user_parameter_base64;
  }

  bool operator!=(const UserParametersType& other) const {
    return !(*this == other);
  }
};

enum class WaveformType {
  kEcg = 0,
  kPulse = 1,
  kRespiratory = 2,
  kTrigger = 3,
  kGradientwaveform = 4,
  kOther = 5,
};

struct WaveformInformationType {
  std::string waveform_name{};
  mrd::WaveformType waveform_type{};
  mrd::UserParametersType user_parameters{};

  bool operator==(const WaveformInformationType& other) const {
    return waveform_name == other.waveform_name &&
      waveform_type == other.waveform_type &&
      user_parameters == other.user_parameters;
  }

  bool operator!=(const WaveformInformationType& other) const {
    return !(*this == other);
  }
};

struct Header {
  std::optional<int64_t> version{};
  std::optional<mrd::SubjectInformationType> subject_information{};
  std::optional<mrd::StudyInformationType> study_information{};
  std::optional<mrd::MeasurementInformationType> measurement_information{};
  std::optional<mrd::AcquisitionSystemInformationType> acquisition_system_information{};
  mrd::ExperimentalConditionsType experimental_conditions{};
  std::vector<mrd::EncodingType> encoding{};
  std::optional<mrd::SequenceParametersType> sequence_parameters{};
  std::optional<mrd::UserParametersType> user_parameters{};
  std::vector<mrd::WaveformInformationType> waveform_information{};

  bool operator==(const Header& other) const {
    return version == other.version &&
      subject_information == other.subject_information &&
      study_information == other.study_information &&
      measurement_information == other.measurement_information &&
      acquisition_system_information == other.acquisition_system_information &&
      experimental_conditions == other.experimental_conditions &&
      encoding == other.encoding &&
      sequence_parameters == other.sequence_parameters &&
      user_parameters == other.user_parameters &&
      waveform_information == other.waveform_information;
  }

  bool operator!=(const Header& other) const {
    return !(*this == other);
  }
};

struct ImageFlags : yardl::BaseFlags<uint64_t, ImageFlags> {
  using BaseFlags::BaseFlags;
  static const ImageFlags kIsNavigationData;
  static const ImageFlags kFirstInAverage;
  static const ImageFlags kLastInAverage;
  static const ImageFlags kFirstInSlice;
  static const ImageFlags kLastInSlice;
  static const ImageFlags kFirstInContrast;
  static const ImageFlags kLastInContrast;
  static const ImageFlags kFirstInPhase;
  static const ImageFlags kLastInPhase;
  static const ImageFlags kFirstInRepetition;
  static const ImageFlags kLastInRepetition;
  static const ImageFlags kFirstInSet;
  static const ImageFlags kLastInSet;
};

enum class ImageType {
  kMagnitude = 1,
  kPhase = 2,
  kReal = 3,
  kImag = 4,
  kComplex = 5,
};

template <typename Y>
using ImageData = yardl::NDArray<Y, 4>;

struct ImageHeader {
  // A bit mask of common attributes applicable to individual images
  mrd::ImageFlags flags{};
  // Unique ID corresponding to the image
  uint32_t measurement_uid{};
  // Physical size (in mm) in each of the 3 dimensions in the image
  yardl::FixedNDArray<float, 3> field_of_view{};
  // Center of the excited volume, in LPS coordinates relative to isocenter in millimeters
  yardl::FixedNDArray<float, 3> position{};
  // Directional cosine of readout/frequency encoding
  yardl::FixedNDArray<float, 3> col_dir{};
  // Directional cosine of phase encoding (2D)
  yardl::FixedNDArray<float, 3> line_dir{};
  // Directional cosine of 3D phase encoding direction
  yardl::FixedNDArray<float, 3> slice_dir{};
  // Offset position of the patient table, in LPS coordinates
  yardl::FixedNDArray<float, 3> patient_table_position{};
  // Signal average
  std::optional<uint32_t> average{};
  // Slice number (multi-slice 2D)
  std::optional<uint32_t> slice{};
  // Echo number in multi-echo
  std::optional<uint32_t> contrast{};
  // Cardiac phase
  std::optional<uint32_t> phase{};
  // Counter in repeated/dynamic acquisitions
  std::optional<uint32_t> repetition{};
  // Sets of different preparation, e.g. flow encoding, diffusion weighting
  std::optional<uint32_t> set{};
  // Clock time stamp (e.g. milliseconds since midnight)
  std::optional<uint32_t> acquisition_time_stamp{};
  // Time stamps relative to physiological triggering, e.g. ECG, pulse oximetry, respiratory
  std::vector<uint32_t> physiology_time_stamp{};
  // Interpretation type of the image
  mrd::ImageType image_type{};
  // Image index number within a series of images, corresponding to DICOM InstanceNumber (0020,0013)
  std::optional<uint32_t> image_index{};
  // Series index, used to separate images into different series, corresponding to DICOM SeriesNumber (0020,0011)
  std::optional<uint32_t> image_series_index{};
  // User-defined int parameters
  std::vector<int32_t> user_int{};
  // User-defined float parameters
  std::vector<float> user_float{};

  bool operator==(const ImageHeader& other) const {
    return flags == other.flags &&
      measurement_uid == other.measurement_uid &&
      field_of_view == other.field_of_view &&
      position == other.position &&
      col_dir == other.col_dir &&
      line_dir == other.line_dir &&
      slice_dir == other.slice_dir &&
      patient_table_position == other.patient_table_position &&
      average == other.average &&
      slice == other.slice &&
      contrast == other.contrast &&
      phase == other.phase &&
      repetition == other.repetition &&
      set == other.set &&
      acquisition_time_stamp == other.acquisition_time_stamp &&
      physiology_time_stamp == other.physiology_time_stamp &&
      image_type == other.image_type &&
      image_index == other.image_index &&
      image_series_index == other.image_series_index &&
      user_int == other.user_int &&
      user_float == other.user_float;
  }

  bool operator!=(const ImageHeader& other) const {
    return !(*this == other);
  }
};

using ImageMetaValue = std::variant<std::string, int64_t, double>;

using ImageMeta = std::unordered_map<std::string, std::vector<mrd::ImageMetaValue>>;

template <typename T>
struct Image {
  // Image header
  mrd::ImageHeader head{};
  // Image data array
  mrd::ImageData<T> data{};
  // Meta attributes
  mrd::ImageMeta meta{};

  yardl::Size Channels() const {
    return yardl::shape(data, 0);
  }

  yardl::Size Slices() const {
    return yardl::shape(data, 1);
  }

  yardl::Size Rows() const {
    return yardl::shape(data, 2);
  }

  yardl::Size Cols() const {
    return yardl::shape(data, 3);
  }

  bool operator==(const Image& other) const {
    return head == other.head &&
      data == other.data &&
      meta == other.meta;
  }

  bool operator!=(const Image& other) const {
    return !(*this == other);
  }
};

using ImageUint16 = mrd::Image<uint16_t>;

using ImageInt16 = mrd::Image<int16_t>;

using ImageUint32 = mrd::Image<uint32_t>;

using ImageInt32 = mrd::Image<int32_t>;

using ImageFloat = mrd::Image<float>;

using ImageDouble = mrd::Image<double>;

using ImageComplexFloat = mrd::Image<std::complex<float>>;

using ImageComplexDouble = mrd::Image<std::complex<double>>;

// Union of all MRD Image types
using AnyImage = std::variant<mrd::ImageUint16, mrd::ImageInt16, mrd::ImageUint32, mrd::ImageInt32, mrd::ImageFloat, mrd::ImageDouble, mrd::ImageComplexFloat, mrd::ImageComplexDouble>;

struct NoiseCovariance {
  // Comes from Header.acquisitionSystemInformation.coilLabel
  std::vector<mrd::CoilLabelType> coil_labels{};
  // Comes from Header.acquisitionSystemInformation.relativeReceiverNoiseBandwidth
  float receiver_noise_bandwidth{};
  // Comes from Acquisition.sampleTimeUs
  float noise_dwell_time_us{};
  // Number of samples used to compute matrix
  yardl::Size sample_count{};
  // Noise covariance matrix with dimensions [coil, coil]
  yardl::NDArray<std::complex<float>, 2> matrix{};

  bool operator==(const NoiseCovariance& other) const {
    return coil_labels == other.coil_labels &&
      receiver_noise_bandwidth == other.receiver_noise_bandwidth &&
      noise_dwell_time_us == other.noise_dwell_time_us &&
      sample_count == other.sample_count &&
      matrix == other.matrix;
  }

  bool operator!=(const NoiseCovariance& other) const {
    return !(*this == other);
  }
};

template <typename T>
using WaveformSamples = yardl::NDArray<T, 2>;

template <typename T>
struct Waveform {
  // Bit field of flags. Currently unused
  uint64_t flags{};
  // Unique ID for this measurement
  uint32_t measurement_uid{};
  // Number of the acquisition after this waveform
  uint32_t scan_counter{};
  // Starting timestamp of this waveform
  uint32_t time_stamp{};
  // Time between samples in microseconds
  float sample_time_us{};
  // ID matching the waveform in the MRD header
  uint32_t waveform_id{};
  // Waveform sample array
  mrd::WaveformSamples<T> data{};

  yardl::Size Channels() const {
    return yardl::shape(data, 0);
  }

  yardl::Size NumberOfSamples() const {
    return yardl::shape(data, 1);
  }

  bool operator==(const Waveform& other) const {
    return flags == other.flags &&
      measurement_uid == other.measurement_uid &&
      scan_counter == other.scan_counter &&
      time_stamp == other.time_stamp &&
      sample_time_us == other.sample_time_us &&
      waveform_id == other.waveform_id &&
      data == other.data;
  }

  bool operator!=(const Waveform& other) const {
    return !(*this == other);
  }
};

using WaveformUint32 = mrd::Waveform<uint32_t>;

struct AcquisitionBucket {
  std::vector<mrd::Acquisition> data{};
  std::vector<mrd::Acquisition> ref{};
  std::vector<mrd::EncodingLimitsType> datastats{};
  std::vector<mrd::EncodingLimitsType> refstats{};
  std::vector<mrd::WaveformUint32> waveforms{};

  bool operator==(const AcquisitionBucket& other) const {
    return data == other.data &&
      ref == other.ref &&
      datastats == other.datastats &&
      refstats == other.refstats &&
      waveforms == other.waveforms;
  }

  bool operator!=(const AcquisitionBucket& other) const {
    return !(*this == other);
  }
};

// Sampled range along E0, E1, E2 (for asymmetric echo and partial fourier)
struct SamplingLimits {
  mrd::LimitType kspace_encoding_step_0{};
  mrd::LimitType kspace_encoding_step_1{};
  mrd::LimitType kspace_encoding_step_2{};

  bool operator==(const SamplingLimits& other) const {
    return kspace_encoding_step_0 == other.kspace_encoding_step_0 &&
      kspace_encoding_step_1 == other.kspace_encoding_step_1 &&
      kspace_encoding_step_2 == other.kspace_encoding_step_2;
  }

  bool operator!=(const SamplingLimits& other) const {
    return !(*this == other);
  }
};

struct SamplingDescription {
  mrd::FieldOfViewMm encoded_fov{};
  mrd::FieldOfViewMm recon_fov{};
  mrd::MatrixSizeType encoded_matrix{};
  mrd::MatrixSizeType recon_matrix{};
  mrd::SamplingLimits sampling_limits{};

  bool operator==(const SamplingDescription& other) const {
    return encoded_fov == other.encoded_fov &&
      recon_fov == other.recon_fov &&
      encoded_matrix == other.encoded_matrix &&
      recon_matrix == other.recon_matrix &&
      sampling_limits == other.sampling_limits;
  }

  bool operator!=(const SamplingDescription& other) const {
    return !(*this == other);
  }
};

struct ReconBuffer {
  // Buffered Acquisition data
  yardl::NDArray<std::complex<float>, 7> data{};
  // Buffered Trajectory data
  yardl::NDArray<float, 7> trajectory{};
  // Buffered Density weights
  std::optional<yardl::NDArray<float, 6>> density{};
  // Buffered AcquisitionHeaders
  yardl::NDArray<mrd::AcquisitionHeader, 5> headers{};
  // Sampling details for these Acquisitions
  mrd::SamplingDescription sampling{};

  bool operator==(const ReconBuffer& other) const {
    return data == other.data &&
      trajectory == other.trajectory &&
      density == other.density &&
      headers == other.headers &&
      sampling == other.sampling;
  }

  bool operator!=(const ReconBuffer& other) const {
    return !(*this == other);
  }
};

struct ReconAssembly {
  mrd::ReconBuffer data{};
  std::optional<mrd::ReconBuffer> ref{};

  bool operator==(const ReconAssembly& other) const {
    return data == other.data &&
      ref == other.ref;
  }

  bool operator!=(const ReconAssembly& other) const {
    return !(*this == other);
  }
};

struct ReconData {
  std::vector<mrd::ReconAssembly> buffers{};

  bool operator==(const ReconData& other) const {
    return buffers == other.buffers;
  }

  bool operator!=(const ReconData& other) const {
    return !(*this == other);
  }
};

struct ImageArray {
  yardl::NDArray<std::complex<float>, 7> data{};
  yardl::NDArray<mrd::ImageHeader, 3> headers{};
  yardl::NDArray<mrd::ImageMeta, 3> meta{};
  std::vector<mrd::WaveformUint32> waveforms{};

  bool operator==(const ImageArray& other) const {
    return data == other.data &&
      headers == other.headers &&
      meta == other.meta &&
      waveforms == other.waveforms;
  }

  bool operator!=(const ImageArray& other) const {
    return !(*this == other);
  }
};

template <typename T>
using Array = yardl::DynamicNDArray<T>;

using ArrayComplexFloat = mrd::Array<std::complex<float>>;

// Union of all primary types that can be streamed in the MRD Protocol
using StreamItem = std::variant<mrd::Acquisition, mrd::WaveformUint32, mrd::ImageUint16, mrd::ImageInt16, mrd::ImageUint32, mrd::ImageInt32, mrd::ImageFloat, mrd::ImageDouble, mrd::ImageComplexFloat, mrd::ImageComplexDouble, mrd::AcquisitionBucket, mrd::ReconData, mrd::ArrayComplexFloat, mrd::ImageArray>;

} // namespace mrd

