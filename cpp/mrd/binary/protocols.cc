// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#include <cstddef>

#include "../yardl/detail/binary/coded_stream.h"
#include "../yardl/detail/binary/serializers.h"

namespace yardl::binary {
#ifndef _MSC_VER
// Values of offsetof() are only used if types are standard-layout.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

template <>
struct IsTriviallySerializable<mrd::EncodingCounters> {
  using __T__ = mrd::EncodingCounters;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::kspace_encode_step_1)>::value &&
    IsTriviallySerializable<decltype(__T__::kspace_encode_step_2)>::value &&
    IsTriviallySerializable<decltype(__T__::average)>::value &&
    IsTriviallySerializable<decltype(__T__::slice)>::value &&
    IsTriviallySerializable<decltype(__T__::contrast)>::value &&
    IsTriviallySerializable<decltype(__T__::phase)>::value &&
    IsTriviallySerializable<decltype(__T__::repetition)>::value &&
    IsTriviallySerializable<decltype(__T__::set)>::value &&
    IsTriviallySerializable<decltype(__T__::segment)>::value &&
    IsTriviallySerializable<decltype(__T__::user)>::value &&
    (sizeof(__T__) == (sizeof(__T__::kspace_encode_step_1) + sizeof(__T__::kspace_encode_step_2) + sizeof(__T__::average) + sizeof(__T__::slice) + sizeof(__T__::contrast) + sizeof(__T__::phase) + sizeof(__T__::repetition) + sizeof(__T__::set) + sizeof(__T__::segment) + sizeof(__T__::user))) &&
    offsetof(__T__, kspace_encode_step_1) < offsetof(__T__, kspace_encode_step_2) && offsetof(__T__, kspace_encode_step_2) < offsetof(__T__, average) && offsetof(__T__, average) < offsetof(__T__, slice) && offsetof(__T__, slice) < offsetof(__T__, contrast) && offsetof(__T__, contrast) < offsetof(__T__, phase) && offsetof(__T__, phase) < offsetof(__T__, repetition) && offsetof(__T__, repetition) < offsetof(__T__, set) && offsetof(__T__, set) < offsetof(__T__, segment) && offsetof(__T__, segment) < offsetof(__T__, user);
};

template <>
struct IsTriviallySerializable<mrd::Acquisition> {
  using __T__ = mrd::Acquisition;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::flags)>::value &&
    IsTriviallySerializable<decltype(__T__::idx)>::value &&
    IsTriviallySerializable<decltype(__T__::measurement_uid)>::value &&
    IsTriviallySerializable<decltype(__T__::scan_counter)>::value &&
    IsTriviallySerializable<decltype(__T__::acquisition_time_stamp)>::value &&
    IsTriviallySerializable<decltype(__T__::physiology_time_stamp)>::value &&
    IsTriviallySerializable<decltype(__T__::channel_order)>::value &&
    IsTriviallySerializable<decltype(__T__::discard_pre)>::value &&
    IsTriviallySerializable<decltype(__T__::discard_post)>::value &&
    IsTriviallySerializable<decltype(__T__::center_sample)>::value &&
    IsTriviallySerializable<decltype(__T__::encoding_space_ref)>::value &&
    IsTriviallySerializable<decltype(__T__::sample_time_us)>::value &&
    IsTriviallySerializable<decltype(__T__::position)>::value &&
    IsTriviallySerializable<decltype(__T__::read_dir)>::value &&
    IsTriviallySerializable<decltype(__T__::phase_dir)>::value &&
    IsTriviallySerializable<decltype(__T__::slice_dir)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_table_position)>::value &&
    IsTriviallySerializable<decltype(__T__::user_int)>::value &&
    IsTriviallySerializable<decltype(__T__::user_float)>::value &&
    IsTriviallySerializable<decltype(__T__::data)>::value &&
    IsTriviallySerializable<decltype(__T__::trajectory)>::value &&
    (sizeof(__T__) == (sizeof(__T__::flags) + sizeof(__T__::idx) + sizeof(__T__::measurement_uid) + sizeof(__T__::scan_counter) + sizeof(__T__::acquisition_time_stamp) + sizeof(__T__::physiology_time_stamp) + sizeof(__T__::channel_order) + sizeof(__T__::discard_pre) + sizeof(__T__::discard_post) + sizeof(__T__::center_sample) + sizeof(__T__::encoding_space_ref) + sizeof(__T__::sample_time_us) + sizeof(__T__::position) + sizeof(__T__::read_dir) + sizeof(__T__::phase_dir) + sizeof(__T__::slice_dir) + sizeof(__T__::patient_table_position) + sizeof(__T__::user_int) + sizeof(__T__::user_float) + sizeof(__T__::data) + sizeof(__T__::trajectory))) &&
    offsetof(__T__, flags) < offsetof(__T__, idx) && offsetof(__T__, idx) < offsetof(__T__, measurement_uid) && offsetof(__T__, measurement_uid) < offsetof(__T__, scan_counter) && offsetof(__T__, scan_counter) < offsetof(__T__, acquisition_time_stamp) && offsetof(__T__, acquisition_time_stamp) < offsetof(__T__, physiology_time_stamp) && offsetof(__T__, physiology_time_stamp) < offsetof(__T__, channel_order) && offsetof(__T__, channel_order) < offsetof(__T__, discard_pre) && offsetof(__T__, discard_pre) < offsetof(__T__, discard_post) && offsetof(__T__, discard_post) < offsetof(__T__, center_sample) && offsetof(__T__, center_sample) < offsetof(__T__, encoding_space_ref) && offsetof(__T__, encoding_space_ref) < offsetof(__T__, sample_time_us) && offsetof(__T__, sample_time_us) < offsetof(__T__, position) && offsetof(__T__, position) < offsetof(__T__, read_dir) && offsetof(__T__, read_dir) < offsetof(__T__, phase_dir) && offsetof(__T__, phase_dir) < offsetof(__T__, slice_dir) && offsetof(__T__, slice_dir) < offsetof(__T__, patient_table_position) && offsetof(__T__, patient_table_position) < offsetof(__T__, user_int) && offsetof(__T__, user_int) < offsetof(__T__, user_float) && offsetof(__T__, user_float) < offsetof(__T__, data) && offsetof(__T__, data) < offsetof(__T__, trajectory);
};

template <>
struct IsTriviallySerializable<mrd::SubjectInformationType> {
  using __T__ = mrd::SubjectInformationType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::patient_name)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_weight_kg)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_height_m)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_id)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_birthdate)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_gender)>::value &&
    (sizeof(__T__) == (sizeof(__T__::patient_name) + sizeof(__T__::patient_weight_kg) + sizeof(__T__::patient_height_m) + sizeof(__T__::patient_id) + sizeof(__T__::patient_birthdate) + sizeof(__T__::patient_gender))) &&
    offsetof(__T__, patient_name) < offsetof(__T__, patient_weight_kg) && offsetof(__T__, patient_weight_kg) < offsetof(__T__, patient_height_m) && offsetof(__T__, patient_height_m) < offsetof(__T__, patient_id) && offsetof(__T__, patient_id) < offsetof(__T__, patient_birthdate) && offsetof(__T__, patient_birthdate) < offsetof(__T__, patient_gender);
};

template <>
struct IsTriviallySerializable<mrd::StudyInformationType> {
  using __T__ = mrd::StudyInformationType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::study_date)>::value &&
    IsTriviallySerializable<decltype(__T__::study_time)>::value &&
    IsTriviallySerializable<decltype(__T__::study_id)>::value &&
    IsTriviallySerializable<decltype(__T__::accession_number)>::value &&
    IsTriviallySerializable<decltype(__T__::referring_physician_name)>::value &&
    IsTriviallySerializable<decltype(__T__::study_description)>::value &&
    IsTriviallySerializable<decltype(__T__::study_instance_uid)>::value &&
    IsTriviallySerializable<decltype(__T__::body_part_examined)>::value &&
    (sizeof(__T__) == (sizeof(__T__::study_date) + sizeof(__T__::study_time) + sizeof(__T__::study_id) + sizeof(__T__::accession_number) + sizeof(__T__::referring_physician_name) + sizeof(__T__::study_description) + sizeof(__T__::study_instance_uid) + sizeof(__T__::body_part_examined))) &&
    offsetof(__T__, study_date) < offsetof(__T__, study_time) && offsetof(__T__, study_time) < offsetof(__T__, study_id) && offsetof(__T__, study_id) < offsetof(__T__, accession_number) && offsetof(__T__, accession_number) < offsetof(__T__, referring_physician_name) && offsetof(__T__, referring_physician_name) < offsetof(__T__, study_description) && offsetof(__T__, study_description) < offsetof(__T__, study_instance_uid) && offsetof(__T__, study_instance_uid) < offsetof(__T__, body_part_examined);
};

template <>
struct IsTriviallySerializable<mrd::ThreeDimensionalFloat> {
  using __T__ = mrd::ThreeDimensionalFloat;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::x)>::value &&
    IsTriviallySerializable<decltype(__T__::y)>::value &&
    IsTriviallySerializable<decltype(__T__::z)>::value &&
    (sizeof(__T__) == (sizeof(__T__::x) + sizeof(__T__::y) + sizeof(__T__::z))) &&
    offsetof(__T__, x) < offsetof(__T__, y) && offsetof(__T__, y) < offsetof(__T__, z);
};

template <>
struct IsTriviallySerializable<mrd::MeasurementDependencyType> {
  using __T__ = mrd::MeasurementDependencyType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::dependency_type)>::value &&
    IsTriviallySerializable<decltype(__T__::measurement_id)>::value &&
    (sizeof(__T__) == (sizeof(__T__::dependency_type) + sizeof(__T__::measurement_id))) &&
    offsetof(__T__, dependency_type) < offsetof(__T__, measurement_id);
};

template <>
struct IsTriviallySerializable<mrd::ReferencedImageSequenceType> {
  using __T__ = mrd::ReferencedImageSequenceType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::referenced_sop_instance_uid)>::value &&
    (sizeof(__T__) == (sizeof(__T__::referenced_sop_instance_uid)));
};

template <>
struct IsTriviallySerializable<mrd::MeasurementInformationType> {
  using __T__ = mrd::MeasurementInformationType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::measurement_id)>::value &&
    IsTriviallySerializable<decltype(__T__::series_date)>::value &&
    IsTriviallySerializable<decltype(__T__::series_time)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_position)>::value &&
    IsTriviallySerializable<decltype(__T__::relative_table_position)>::value &&
    IsTriviallySerializable<decltype(__T__::initial_series_number)>::value &&
    IsTriviallySerializable<decltype(__T__::protocol_name)>::value &&
    IsTriviallySerializable<decltype(__T__::sequence_name)>::value &&
    IsTriviallySerializable<decltype(__T__::series_description)>::value &&
    IsTriviallySerializable<decltype(__T__::measurement_dependency)>::value &&
    IsTriviallySerializable<decltype(__T__::series_instance_uid_root)>::value &&
    IsTriviallySerializable<decltype(__T__::frame_of_reference_uid)>::value &&
    IsTriviallySerializable<decltype(__T__::referenced_image_sequence)>::value &&
    (sizeof(__T__) == (sizeof(__T__::measurement_id) + sizeof(__T__::series_date) + sizeof(__T__::series_time) + sizeof(__T__::patient_position) + sizeof(__T__::relative_table_position) + sizeof(__T__::initial_series_number) + sizeof(__T__::protocol_name) + sizeof(__T__::sequence_name) + sizeof(__T__::series_description) + sizeof(__T__::measurement_dependency) + sizeof(__T__::series_instance_uid_root) + sizeof(__T__::frame_of_reference_uid) + sizeof(__T__::referenced_image_sequence))) &&
    offsetof(__T__, measurement_id) < offsetof(__T__, series_date) && offsetof(__T__, series_date) < offsetof(__T__, series_time) && offsetof(__T__, series_time) < offsetof(__T__, patient_position) && offsetof(__T__, patient_position) < offsetof(__T__, relative_table_position) && offsetof(__T__, relative_table_position) < offsetof(__T__, initial_series_number) && offsetof(__T__, initial_series_number) < offsetof(__T__, protocol_name) && offsetof(__T__, protocol_name) < offsetof(__T__, sequence_name) && offsetof(__T__, sequence_name) < offsetof(__T__, series_description) && offsetof(__T__, series_description) < offsetof(__T__, measurement_dependency) && offsetof(__T__, measurement_dependency) < offsetof(__T__, series_instance_uid_root) && offsetof(__T__, series_instance_uid_root) < offsetof(__T__, frame_of_reference_uid) && offsetof(__T__, frame_of_reference_uid) < offsetof(__T__, referenced_image_sequence);
};

template <>
struct IsTriviallySerializable<mrd::CoilLabelType> {
  using __T__ = mrd::CoilLabelType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::coil_number)>::value &&
    IsTriviallySerializable<decltype(__T__::coil_name)>::value &&
    (sizeof(__T__) == (sizeof(__T__::coil_number) + sizeof(__T__::coil_name))) &&
    offsetof(__T__, coil_number) < offsetof(__T__, coil_name);
};

template <>
struct IsTriviallySerializable<mrd::AcquisitionSystemInformationType> {
  using __T__ = mrd::AcquisitionSystemInformationType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::system_vendor)>::value &&
    IsTriviallySerializable<decltype(__T__::system_model)>::value &&
    IsTriviallySerializable<decltype(__T__::system_field_strength_t)>::value &&
    IsTriviallySerializable<decltype(__T__::relative_receiver_noise_bandwidth)>::value &&
    IsTriviallySerializable<decltype(__T__::receiver_channels)>::value &&
    IsTriviallySerializable<decltype(__T__::coil_label)>::value &&
    IsTriviallySerializable<decltype(__T__::institution_name)>::value &&
    IsTriviallySerializable<decltype(__T__::station_name)>::value &&
    IsTriviallySerializable<decltype(__T__::device_id)>::value &&
    IsTriviallySerializable<decltype(__T__::device_serial_number)>::value &&
    (sizeof(__T__) == (sizeof(__T__::system_vendor) + sizeof(__T__::system_model) + sizeof(__T__::system_field_strength_t) + sizeof(__T__::relative_receiver_noise_bandwidth) + sizeof(__T__::receiver_channels) + sizeof(__T__::coil_label) + sizeof(__T__::institution_name) + sizeof(__T__::station_name) + sizeof(__T__::device_id) + sizeof(__T__::device_serial_number))) &&
    offsetof(__T__, system_vendor) < offsetof(__T__, system_model) && offsetof(__T__, system_model) < offsetof(__T__, system_field_strength_t) && offsetof(__T__, system_field_strength_t) < offsetof(__T__, relative_receiver_noise_bandwidth) && offsetof(__T__, relative_receiver_noise_bandwidth) < offsetof(__T__, receiver_channels) && offsetof(__T__, receiver_channels) < offsetof(__T__, coil_label) && offsetof(__T__, coil_label) < offsetof(__T__, institution_name) && offsetof(__T__, institution_name) < offsetof(__T__, station_name) && offsetof(__T__, station_name) < offsetof(__T__, device_id) && offsetof(__T__, device_id) < offsetof(__T__, device_serial_number);
};

template <>
struct IsTriviallySerializable<mrd::ExperimentalConditionsType> {
  using __T__ = mrd::ExperimentalConditionsType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::h1resonance_frequency_hz)>::value &&
    (sizeof(__T__) == (sizeof(__T__::h1resonance_frequency_hz)));
};

template <>
struct IsTriviallySerializable<mrd::MatrixSizeType> {
  using __T__ = mrd::MatrixSizeType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::x)>::value &&
    IsTriviallySerializable<decltype(__T__::y)>::value &&
    IsTriviallySerializable<decltype(__T__::z)>::value &&
    (sizeof(__T__) == (sizeof(__T__::x) + sizeof(__T__::y) + sizeof(__T__::z))) &&
    offsetof(__T__, x) < offsetof(__T__, y) && offsetof(__T__, y) < offsetof(__T__, z);
};

template <>
struct IsTriviallySerializable<mrd::FieldOfViewMm> {
  using __T__ = mrd::FieldOfViewMm;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::x)>::value &&
    IsTriviallySerializable<decltype(__T__::y)>::value &&
    IsTriviallySerializable<decltype(__T__::z)>::value &&
    (sizeof(__T__) == (sizeof(__T__::x) + sizeof(__T__::y) + sizeof(__T__::z))) &&
    offsetof(__T__, x) < offsetof(__T__, y) && offsetof(__T__, y) < offsetof(__T__, z);
};

template <>
struct IsTriviallySerializable<mrd::EncodingSpaceType> {
  using __T__ = mrd::EncodingSpaceType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::matrix_size)>::value &&
    IsTriviallySerializable<decltype(__T__::field_of_view_mm)>::value &&
    (sizeof(__T__) == (sizeof(__T__::matrix_size) + sizeof(__T__::field_of_view_mm))) &&
    offsetof(__T__, matrix_size) < offsetof(__T__, field_of_view_mm);
};

template <>
struct IsTriviallySerializable<mrd::LimitType> {
  using __T__ = mrd::LimitType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::minimum)>::value &&
    IsTriviallySerializable<decltype(__T__::maximum)>::value &&
    IsTriviallySerializable<decltype(__T__::center)>::value &&
    (sizeof(__T__) == (sizeof(__T__::minimum) + sizeof(__T__::maximum) + sizeof(__T__::center))) &&
    offsetof(__T__, minimum) < offsetof(__T__, maximum) && offsetof(__T__, maximum) < offsetof(__T__, center);
};

template <>
struct IsTriviallySerializable<mrd::EncodingLimitsType> {
  using __T__ = mrd::EncodingLimitsType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::kspace_encoding_step_0)>::value &&
    IsTriviallySerializable<decltype(__T__::kspace_encoding_step_1)>::value &&
    IsTriviallySerializable<decltype(__T__::kspace_encoding_step_2)>::value &&
    IsTriviallySerializable<decltype(__T__::average)>::value &&
    IsTriviallySerializable<decltype(__T__::slice)>::value &&
    IsTriviallySerializable<decltype(__T__::contrast)>::value &&
    IsTriviallySerializable<decltype(__T__::phase)>::value &&
    IsTriviallySerializable<decltype(__T__::repetition)>::value &&
    IsTriviallySerializable<decltype(__T__::set)>::value &&
    IsTriviallySerializable<decltype(__T__::segment)>::value &&
    IsTriviallySerializable<decltype(__T__::user_0)>::value &&
    IsTriviallySerializable<decltype(__T__::user_1)>::value &&
    IsTriviallySerializable<decltype(__T__::user_2)>::value &&
    IsTriviallySerializable<decltype(__T__::user_3)>::value &&
    IsTriviallySerializable<decltype(__T__::user_4)>::value &&
    IsTriviallySerializable<decltype(__T__::user_5)>::value &&
    IsTriviallySerializable<decltype(__T__::user_6)>::value &&
    IsTriviallySerializable<decltype(__T__::user_7)>::value &&
    (sizeof(__T__) == (sizeof(__T__::kspace_encoding_step_0) + sizeof(__T__::kspace_encoding_step_1) + sizeof(__T__::kspace_encoding_step_2) + sizeof(__T__::average) + sizeof(__T__::slice) + sizeof(__T__::contrast) + sizeof(__T__::phase) + sizeof(__T__::repetition) + sizeof(__T__::set) + sizeof(__T__::segment) + sizeof(__T__::user_0) + sizeof(__T__::user_1) + sizeof(__T__::user_2) + sizeof(__T__::user_3) + sizeof(__T__::user_4) + sizeof(__T__::user_5) + sizeof(__T__::user_6) + sizeof(__T__::user_7))) &&
    offsetof(__T__, kspace_encoding_step_0) < offsetof(__T__, kspace_encoding_step_1) && offsetof(__T__, kspace_encoding_step_1) < offsetof(__T__, kspace_encoding_step_2) && offsetof(__T__, kspace_encoding_step_2) < offsetof(__T__, average) && offsetof(__T__, average) < offsetof(__T__, slice) && offsetof(__T__, slice) < offsetof(__T__, contrast) && offsetof(__T__, contrast) < offsetof(__T__, phase) && offsetof(__T__, phase) < offsetof(__T__, repetition) && offsetof(__T__, repetition) < offsetof(__T__, set) && offsetof(__T__, set) < offsetof(__T__, segment) && offsetof(__T__, segment) < offsetof(__T__, user_0) && offsetof(__T__, user_0) < offsetof(__T__, user_1) && offsetof(__T__, user_1) < offsetof(__T__, user_2) && offsetof(__T__, user_2) < offsetof(__T__, user_3) && offsetof(__T__, user_3) < offsetof(__T__, user_4) && offsetof(__T__, user_4) < offsetof(__T__, user_5) && offsetof(__T__, user_5) < offsetof(__T__, user_6) && offsetof(__T__, user_6) < offsetof(__T__, user_7);
};

template <>
struct IsTriviallySerializable<mrd::UserParameterLongType> {
  using __T__ = mrd::UserParameterLongType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::value))) &&
    offsetof(__T__, name) < offsetof(__T__, value);
};

template <>
struct IsTriviallySerializable<mrd::UserParameterDoubleType> {
  using __T__ = mrd::UserParameterDoubleType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::value))) &&
    offsetof(__T__, name) < offsetof(__T__, value);
};

template <>
struct IsTriviallySerializable<mrd::UserParameterStringType> {
  using __T__ = mrd::UserParameterStringType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::value))) &&
    offsetof(__T__, name) < offsetof(__T__, value);
};

template <>
struct IsTriviallySerializable<mrd::TrajectoryDescriptionType> {
  using __T__ = mrd::TrajectoryDescriptionType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::identifier)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameter_long)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameter_double)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameter_string)>::value &&
    IsTriviallySerializable<decltype(__T__::comment)>::value &&
    (sizeof(__T__) == (sizeof(__T__::identifier) + sizeof(__T__::user_parameter_long) + sizeof(__T__::user_parameter_double) + sizeof(__T__::user_parameter_string) + sizeof(__T__::comment))) &&
    offsetof(__T__, identifier) < offsetof(__T__, user_parameter_long) && offsetof(__T__, user_parameter_long) < offsetof(__T__, user_parameter_double) && offsetof(__T__, user_parameter_double) < offsetof(__T__, user_parameter_string) && offsetof(__T__, user_parameter_string) < offsetof(__T__, comment);
};

template <>
struct IsTriviallySerializable<mrd::AccelerationFactorType> {
  using __T__ = mrd::AccelerationFactorType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::kspace_encoding_step_1)>::value &&
    IsTriviallySerializable<decltype(__T__::kspace_encoding_step_2)>::value &&
    (sizeof(__T__) == (sizeof(__T__::kspace_encoding_step_1) + sizeof(__T__::kspace_encoding_step_2))) &&
    offsetof(__T__, kspace_encoding_step_1) < offsetof(__T__, kspace_encoding_step_2);
};

template <>
struct IsTriviallySerializable<mrd::MultibandSpacingType> {
  using __T__ = mrd::MultibandSpacingType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::d_z)>::value &&
    (sizeof(__T__) == (sizeof(__T__::d_z)));
};

template <>
struct IsTriviallySerializable<mrd::MultibandType> {
  using __T__ = mrd::MultibandType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::spacing)>::value &&
    IsTriviallySerializable<decltype(__T__::delta_kz)>::value &&
    IsTriviallySerializable<decltype(__T__::multiband_factor)>::value &&
    IsTriviallySerializable<decltype(__T__::calibration)>::value &&
    IsTriviallySerializable<decltype(__T__::calibration_encoding)>::value &&
    (sizeof(__T__) == (sizeof(__T__::spacing) + sizeof(__T__::delta_kz) + sizeof(__T__::multiband_factor) + sizeof(__T__::calibration) + sizeof(__T__::calibration_encoding))) &&
    offsetof(__T__, spacing) < offsetof(__T__, delta_kz) && offsetof(__T__, delta_kz) < offsetof(__T__, multiband_factor) && offsetof(__T__, multiband_factor) < offsetof(__T__, calibration) && offsetof(__T__, calibration) < offsetof(__T__, calibration_encoding);
};

template <>
struct IsTriviallySerializable<mrd::ParallelImagingType> {
  using __T__ = mrd::ParallelImagingType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::acceleration_factor)>::value &&
    IsTriviallySerializable<decltype(__T__::calibration_mode)>::value &&
    IsTriviallySerializable<decltype(__T__::interleaving_dimension)>::value &&
    IsTriviallySerializable<decltype(__T__::multiband)>::value &&
    (sizeof(__T__) == (sizeof(__T__::acceleration_factor) + sizeof(__T__::calibration_mode) + sizeof(__T__::interleaving_dimension) + sizeof(__T__::multiband))) &&
    offsetof(__T__, acceleration_factor) < offsetof(__T__, calibration_mode) && offsetof(__T__, calibration_mode) < offsetof(__T__, interleaving_dimension) && offsetof(__T__, interleaving_dimension) < offsetof(__T__, multiband);
};

template <>
struct IsTriviallySerializable<mrd::EncodingType> {
  using __T__ = mrd::EncodingType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::encoded_space)>::value &&
    IsTriviallySerializable<decltype(__T__::recon_space)>::value &&
    IsTriviallySerializable<decltype(__T__::encoding_limits)>::value &&
    IsTriviallySerializable<decltype(__T__::trajectory)>::value &&
    IsTriviallySerializable<decltype(__T__::trajectory_description)>::value &&
    IsTriviallySerializable<decltype(__T__::parallel_imaging)>::value &&
    IsTriviallySerializable<decltype(__T__::echo_train_length)>::value &&
    (sizeof(__T__) == (sizeof(__T__::encoded_space) + sizeof(__T__::recon_space) + sizeof(__T__::encoding_limits) + sizeof(__T__::trajectory) + sizeof(__T__::trajectory_description) + sizeof(__T__::parallel_imaging) + sizeof(__T__::echo_train_length))) &&
    offsetof(__T__, encoded_space) < offsetof(__T__, recon_space) && offsetof(__T__, recon_space) < offsetof(__T__, encoding_limits) && offsetof(__T__, encoding_limits) < offsetof(__T__, trajectory) && offsetof(__T__, trajectory) < offsetof(__T__, trajectory_description) && offsetof(__T__, trajectory_description) < offsetof(__T__, parallel_imaging) && offsetof(__T__, parallel_imaging) < offsetof(__T__, echo_train_length);
};

template <>
struct IsTriviallySerializable<mrd::GradientDirectionType> {
  using __T__ = mrd::GradientDirectionType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::rl)>::value &&
    IsTriviallySerializable<decltype(__T__::ap)>::value &&
    IsTriviallySerializable<decltype(__T__::fh)>::value &&
    (sizeof(__T__) == (sizeof(__T__::rl) + sizeof(__T__::ap) + sizeof(__T__::fh))) &&
    offsetof(__T__, rl) < offsetof(__T__, ap) && offsetof(__T__, ap) < offsetof(__T__, fh);
};

template <>
struct IsTriviallySerializable<mrd::DiffusionType> {
  using __T__ = mrd::DiffusionType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::gradient_direction)>::value &&
    IsTriviallySerializable<decltype(__T__::bvalue)>::value &&
    (sizeof(__T__) == (sizeof(__T__::gradient_direction) + sizeof(__T__::bvalue))) &&
    offsetof(__T__, gradient_direction) < offsetof(__T__, bvalue);
};

template <>
struct IsTriviallySerializable<mrd::SequenceParametersType> {
  using __T__ = mrd::SequenceParametersType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::t_r)>::value &&
    IsTriviallySerializable<decltype(__T__::t_e)>::value &&
    IsTriviallySerializable<decltype(__T__::t_i)>::value &&
    IsTriviallySerializable<decltype(__T__::flip_angle_deg)>::value &&
    IsTriviallySerializable<decltype(__T__::sequence_type)>::value &&
    IsTriviallySerializable<decltype(__T__::echo_spacing)>::value &&
    IsTriviallySerializable<decltype(__T__::diffusion_dimension)>::value &&
    IsTriviallySerializable<decltype(__T__::diffusion)>::value &&
    IsTriviallySerializable<decltype(__T__::diffusion_scheme)>::value &&
    (sizeof(__T__) == (sizeof(__T__::t_r) + sizeof(__T__::t_e) + sizeof(__T__::t_i) + sizeof(__T__::flip_angle_deg) + sizeof(__T__::sequence_type) + sizeof(__T__::echo_spacing) + sizeof(__T__::diffusion_dimension) + sizeof(__T__::diffusion) + sizeof(__T__::diffusion_scheme))) &&
    offsetof(__T__, t_r) < offsetof(__T__, t_e) && offsetof(__T__, t_e) < offsetof(__T__, t_i) && offsetof(__T__, t_i) < offsetof(__T__, flip_angle_deg) && offsetof(__T__, flip_angle_deg) < offsetof(__T__, sequence_type) && offsetof(__T__, sequence_type) < offsetof(__T__, echo_spacing) && offsetof(__T__, echo_spacing) < offsetof(__T__, diffusion_dimension) && offsetof(__T__, diffusion_dimension) < offsetof(__T__, diffusion) && offsetof(__T__, diffusion) < offsetof(__T__, diffusion_scheme);
};

template <>
struct IsTriviallySerializable<mrd::UserParameterBase64Type> {
  using __T__ = mrd::UserParameterBase64Type;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::value))) &&
    offsetof(__T__, name) < offsetof(__T__, value);
};

template <>
struct IsTriviallySerializable<mrd::UserParametersType> {
  using __T__ = mrd::UserParametersType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::user_parameter_long)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameter_double)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameter_string)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameter_base64)>::value &&
    (sizeof(__T__) == (sizeof(__T__::user_parameter_long) + sizeof(__T__::user_parameter_double) + sizeof(__T__::user_parameter_string) + sizeof(__T__::user_parameter_base64))) &&
    offsetof(__T__, user_parameter_long) < offsetof(__T__, user_parameter_double) && offsetof(__T__, user_parameter_double) < offsetof(__T__, user_parameter_string) && offsetof(__T__, user_parameter_string) < offsetof(__T__, user_parameter_base64);
};

template <>
struct IsTriviallySerializable<mrd::WaveformInformationType> {
  using __T__ = mrd::WaveformInformationType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::waveform_name)>::value &&
    IsTriviallySerializable<decltype(__T__::waveform_type)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameters)>::value &&
    (sizeof(__T__) == (sizeof(__T__::waveform_name) + sizeof(__T__::waveform_type) + sizeof(__T__::user_parameters))) &&
    offsetof(__T__, waveform_name) < offsetof(__T__, waveform_type) && offsetof(__T__, waveform_type) < offsetof(__T__, user_parameters);
};

template <>
struct IsTriviallySerializable<mrd::Header> {
  using __T__ = mrd::Header;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::version)>::value &&
    IsTriviallySerializable<decltype(__T__::subject_information)>::value &&
    IsTriviallySerializable<decltype(__T__::study_information)>::value &&
    IsTriviallySerializable<decltype(__T__::measurement_information)>::value &&
    IsTriviallySerializable<decltype(__T__::acquisition_system_information)>::value &&
    IsTriviallySerializable<decltype(__T__::experimental_conditions)>::value &&
    IsTriviallySerializable<decltype(__T__::encoding)>::value &&
    IsTriviallySerializable<decltype(__T__::sequence_parameters)>::value &&
    IsTriviallySerializable<decltype(__T__::user_parameters)>::value &&
    IsTriviallySerializable<decltype(__T__::waveform_information)>::value &&
    (sizeof(__T__) == (sizeof(__T__::version) + sizeof(__T__::subject_information) + sizeof(__T__::study_information) + sizeof(__T__::measurement_information) + sizeof(__T__::acquisition_system_information) + sizeof(__T__::experimental_conditions) + sizeof(__T__::encoding) + sizeof(__T__::sequence_parameters) + sizeof(__T__::user_parameters) + sizeof(__T__::waveform_information))) &&
    offsetof(__T__, version) < offsetof(__T__, subject_information) && offsetof(__T__, subject_information) < offsetof(__T__, study_information) && offsetof(__T__, study_information) < offsetof(__T__, measurement_information) && offsetof(__T__, measurement_information) < offsetof(__T__, acquisition_system_information) && offsetof(__T__, acquisition_system_information) < offsetof(__T__, experimental_conditions) && offsetof(__T__, experimental_conditions) < offsetof(__T__, encoding) && offsetof(__T__, encoding) < offsetof(__T__, sequence_parameters) && offsetof(__T__, sequence_parameters) < offsetof(__T__, user_parameters) && offsetof(__T__, user_parameters) < offsetof(__T__, waveform_information);
};

template <>
struct IsTriviallySerializable<mrd::ImageMetaData> {
  using __T__ = mrd::ImageMetaData;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::value)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::value))) &&
    offsetof(__T__, name) < offsetof(__T__, value);
};

template <typename T>
struct IsTriviallySerializable<mrd::Image<T>> {
  using __T__ = mrd::Image<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::flags)>::value &&
    IsTriviallySerializable<decltype(__T__::measurement_uid)>::value &&
    IsTriviallySerializable<decltype(__T__::field_of_view)>::value &&
    IsTriviallySerializable<decltype(__T__::position)>::value &&
    IsTriviallySerializable<decltype(__T__::col_dir)>::value &&
    IsTriviallySerializable<decltype(__T__::line_dir)>::value &&
    IsTriviallySerializable<decltype(__T__::slice_dir)>::value &&
    IsTriviallySerializable<decltype(__T__::patient_table_position)>::value &&
    IsTriviallySerializable<decltype(__T__::average)>::value &&
    IsTriviallySerializable<decltype(__T__::slice)>::value &&
    IsTriviallySerializable<decltype(__T__::contrast)>::value &&
    IsTriviallySerializable<decltype(__T__::phase)>::value &&
    IsTriviallySerializable<decltype(__T__::repetition)>::value &&
    IsTriviallySerializable<decltype(__T__::set)>::value &&
    IsTriviallySerializable<decltype(__T__::acquisition_time_stamp)>::value &&
    IsTriviallySerializable<decltype(__T__::physiology_time_stamp)>::value &&
    IsTriviallySerializable<decltype(__T__::image_type)>::value &&
    IsTriviallySerializable<decltype(__T__::image_index)>::value &&
    IsTriviallySerializable<decltype(__T__::image_series_index)>::value &&
    IsTriviallySerializable<decltype(__T__::user_int)>::value &&
    IsTriviallySerializable<decltype(__T__::user_float)>::value &&
    IsTriviallySerializable<decltype(__T__::data)>::value &&
    IsTriviallySerializable<decltype(__T__::meta)>::value &&
    (sizeof(__T__) == (sizeof(__T__::flags) + sizeof(__T__::measurement_uid) + sizeof(__T__::field_of_view) + sizeof(__T__::position) + sizeof(__T__::col_dir) + sizeof(__T__::line_dir) + sizeof(__T__::slice_dir) + sizeof(__T__::patient_table_position) + sizeof(__T__::average) + sizeof(__T__::slice) + sizeof(__T__::contrast) + sizeof(__T__::phase) + sizeof(__T__::repetition) + sizeof(__T__::set) + sizeof(__T__::acquisition_time_stamp) + sizeof(__T__::physiology_time_stamp) + sizeof(__T__::image_type) + sizeof(__T__::image_index) + sizeof(__T__::image_series_index) + sizeof(__T__::user_int) + sizeof(__T__::user_float) + sizeof(__T__::data) + sizeof(__T__::meta))) &&
    offsetof(__T__, flags) < offsetof(__T__, measurement_uid) && offsetof(__T__, measurement_uid) < offsetof(__T__, field_of_view) && offsetof(__T__, field_of_view) < offsetof(__T__, position) && offsetof(__T__, position) < offsetof(__T__, col_dir) && offsetof(__T__, col_dir) < offsetof(__T__, line_dir) && offsetof(__T__, line_dir) < offsetof(__T__, slice_dir) && offsetof(__T__, slice_dir) < offsetof(__T__, patient_table_position) && offsetof(__T__, patient_table_position) < offsetof(__T__, average) && offsetof(__T__, average) < offsetof(__T__, slice) && offsetof(__T__, slice) < offsetof(__T__, contrast) && offsetof(__T__, contrast) < offsetof(__T__, phase) && offsetof(__T__, phase) < offsetof(__T__, repetition) && offsetof(__T__, repetition) < offsetof(__T__, set) && offsetof(__T__, set) < offsetof(__T__, acquisition_time_stamp) && offsetof(__T__, acquisition_time_stamp) < offsetof(__T__, physiology_time_stamp) && offsetof(__T__, physiology_time_stamp) < offsetof(__T__, image_type) && offsetof(__T__, image_type) < offsetof(__T__, image_index) && offsetof(__T__, image_index) < offsetof(__T__, image_series_index) && offsetof(__T__, image_series_index) < offsetof(__T__, user_int) && offsetof(__T__, user_int) < offsetof(__T__, user_float) && offsetof(__T__, user_float) < offsetof(__T__, data) && offsetof(__T__, data) < offsetof(__T__, meta);
};

template <typename T>
struct IsTriviallySerializable<mrd::Waveform<T>> {
  using __T__ = mrd::Waveform<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::flags)>::value &&
    IsTriviallySerializable<decltype(__T__::measurement_uid)>::value &&
    IsTriviallySerializable<decltype(__T__::scan_counter)>::value &&
    IsTriviallySerializable<decltype(__T__::time_stamp)>::value &&
    IsTriviallySerializable<decltype(__T__::sample_time_us)>::value &&
    IsTriviallySerializable<decltype(__T__::waveform_id)>::value &&
    IsTriviallySerializable<decltype(__T__::data)>::value &&
    (sizeof(__T__) == (sizeof(__T__::flags) + sizeof(__T__::measurement_uid) + sizeof(__T__::scan_counter) + sizeof(__T__::time_stamp) + sizeof(__T__::sample_time_us) + sizeof(__T__::waveform_id) + sizeof(__T__::data))) &&
    offsetof(__T__, flags) < offsetof(__T__, measurement_uid) && offsetof(__T__, measurement_uid) < offsetof(__T__, scan_counter) && offsetof(__T__, scan_counter) < offsetof(__T__, time_stamp) && offsetof(__T__, time_stamp) < offsetof(__T__, sample_time_us) && offsetof(__T__, sample_time_us) < offsetof(__T__, waveform_id) && offsetof(__T__, waveform_id) < offsetof(__T__, data);
};

#ifndef _MSC_VER
#pragma GCC diagnostic pop // #pragma GCC diagnostic ignored "-Winvalid-offsetof" 
#endif
} //namespace yardl::binary 

namespace {
template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2, typename T3, yardl::binary::Writer<T3> WriteT3, typename T4, yardl::binary::Writer<T4> WriteT4, typename T5, yardl::binary::Writer<T5> WriteT5, typename T6, yardl::binary::Writer<T6> WriteT6, typename T7, yardl::binary::Writer<T7> WriteT7, typename T8, yardl::binary::Writer<T8> WriteT8, typename T9, yardl::binary::Writer<T9> WriteT9>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  case 2: {
    T2 const& v = std::get<2>(value);
    WriteT2(stream, v);
    break;
  }
  case 3: {
    T3 const& v = std::get<3>(value);
    WriteT3(stream, v);
    break;
  }
  case 4: {
    T4 const& v = std::get<4>(value);
    WriteT4(stream, v);
    break;
  }
  case 5: {
    T5 const& v = std::get<5>(value);
    WriteT5(stream, v);
    break;
  }
  case 6: {
    T6 const& v = std::get<6>(value);
    WriteT6(stream, v);
    break;
  }
  case 7: {
    T7 const& v = std::get<7>(value);
    WriteT7(stream, v);
    break;
  }
  case 8: {
    T8 const& v = std::get<8>(value);
    WriteT8(stream, v);
    break;
  }
  case 9: {
    T9 const& v = std::get<9>(value);
    WriteT9(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2, typename T3, yardl::binary::Reader<T3> ReadT3, typename T4, yardl::binary::Reader<T4> ReadT4, typename T5, yardl::binary::Reader<T5> ReadT5, typename T6, yardl::binary::Reader<T6> ReadT6, typename T7, yardl::binary::Reader<T7> ReadT7, typename T8, yardl::binary::Reader<T8> ReadT8, typename T9, yardl::binary::Reader<T9> ReadT9>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    case 2: {
      T2 v;
      ReadT2(stream, v);
      value = std::move(v);
      break;
    }
    case 3: {
      T3 v;
      ReadT3(stream, v);
      value = std::move(v);
      break;
    }
    case 4: {
      T4 v;
      ReadT4(stream, v);
      value = std::move(v);
      break;
    }
    case 5: {
      T5 v;
      ReadT5(stream, v);
      value = std::move(v);
      break;
    }
    case 6: {
      T6 v;
      ReadT6(stream, v);
      value = std::move(v);
      break;
    }
    case 7: {
      T7 v;
      ReadT7(stream, v);
      value = std::move(v);
      break;
    }
    case 8: {
      T8 v;
      ReadT8(stream, v);
      value = std::move(v);
      break;
    }
    case 9: {
      T9 v;
      ReadT9(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}
} // namespace

namespace mrd::binary {
namespace {
[[maybe_unused]] void WriteEncodingCounters(yardl::binary::CodedOutputStream& stream, mrd::EncodingCounters const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingCounters>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.kspace_encode_step_1);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.kspace_encode_step_2);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.average);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.slice);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.contrast);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.phase);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.repetition);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.set);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.segment);
  yardl::binary::WriteVector<uint32_t, yardl::binary::WriteInteger>(stream, value.user);
}

[[maybe_unused]] void ReadEncodingCounters(yardl::binary::CodedInputStream& stream, mrd::EncodingCounters& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingCounters>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.kspace_encode_step_1);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.kspace_encode_step_2);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.average);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.slice);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.contrast);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.phase);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.repetition);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.set);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.segment);
  yardl::binary::ReadVector<uint32_t, yardl::binary::ReadInteger>(stream, value.user);
}

[[maybe_unused]] void WriteAcquisitionData(yardl::binary::CodedOutputStream& stream, mrd::AcquisitionData const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::AcquisitionData>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<std::complex<float>, yardl::binary::WriteFloatingPoint, 2>(stream, value);
}

[[maybe_unused]] void ReadAcquisitionData(yardl::binary::CodedInputStream& stream, mrd::AcquisitionData& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::AcquisitionData>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<std::complex<float>, yardl::binary::ReadFloatingPoint, 2>(stream, value);
}

[[maybe_unused]] void WriteTrajectoryData(yardl::binary::CodedOutputStream& stream, mrd::TrajectoryData const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::TrajectoryData>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 2>(stream, value);
}

[[maybe_unused]] void ReadTrajectoryData(yardl::binary::CodedInputStream& stream, mrd::TrajectoryData& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::TrajectoryData>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 2>(stream, value);
}

[[maybe_unused]] void WriteAcquisition(yardl::binary::CodedOutputStream& stream, mrd::Acquisition const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Acquisition>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFlags<mrd::AcquisitionFlags>(stream, value.flags);
  mrd::binary::WriteEncodingCounters(stream, value.idx);
  yardl::binary::WriteInteger(stream, value.measurement_uid);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.scan_counter);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.acquisition_time_stamp);
  yardl::binary::WriteVector<uint32_t, yardl::binary::WriteInteger>(stream, value.physiology_time_stamp);
  yardl::binary::WriteVector<uint32_t, yardl::binary::WriteInteger>(stream, value.channel_order);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.discard_pre);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.discard_post);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.center_sample);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.encoding_space_ref);
  yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream, value.sample_time_us);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.position);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.read_dir);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.phase_dir);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.slice_dir);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.patient_table_position);
  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, value.user_int);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.user_float);
  mrd::binary::WriteAcquisitionData(stream, value.data);
  mrd::binary::WriteTrajectoryData(stream, value.trajectory);
}

[[maybe_unused]] void ReadAcquisition(yardl::binary::CodedInputStream& stream, mrd::Acquisition& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Acquisition>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFlags<mrd::AcquisitionFlags>(stream, value.flags);
  mrd::binary::ReadEncodingCounters(stream, value.idx);
  yardl::binary::ReadInteger(stream, value.measurement_uid);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.scan_counter);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.acquisition_time_stamp);
  yardl::binary::ReadVector<uint32_t, yardl::binary::ReadInteger>(stream, value.physiology_time_stamp);
  yardl::binary::ReadVector<uint32_t, yardl::binary::ReadInteger>(stream, value.channel_order);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.discard_pre);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.discard_post);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.center_sample);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.encoding_space_ref);
  yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream, value.sample_time_us);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.position);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.read_dir);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.phase_dir);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.slice_dir);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.patient_table_position);
  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, value.user_int);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.user_float);
  mrd::binary::ReadAcquisitionData(stream, value.data);
  mrd::binary::ReadTrajectoryData(stream, value.trajectory);
}

[[maybe_unused]] void WriteSubjectInformationType(yardl::binary::CodedOutputStream& stream, mrd::SubjectInformationType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::SubjectInformationType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.patient_name);
  yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream, value.patient_weight_kg);
  yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream, value.patient_height_m);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.patient_id);
  yardl::binary::WriteOptional<yardl::Date, yardl::binary::WriteDate>(stream, value.patient_birthdate);
  yardl::binary::WriteOptional<mrd::PatientGender, yardl::binary::WriteEnum<mrd::PatientGender>>(stream, value.patient_gender);
}

[[maybe_unused]] void ReadSubjectInformationType(yardl::binary::CodedInputStream& stream, mrd::SubjectInformationType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::SubjectInformationType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.patient_name);
  yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream, value.patient_weight_kg);
  yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream, value.patient_height_m);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.patient_id);
  yardl::binary::ReadOptional<yardl::Date, yardl::binary::ReadDate>(stream, value.patient_birthdate);
  yardl::binary::ReadOptional<mrd::PatientGender, yardl::binary::ReadEnum<mrd::PatientGender>>(stream, value.patient_gender);
}

[[maybe_unused]] void WriteStudyInformationType(yardl::binary::CodedOutputStream& stream, mrd::StudyInformationType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::StudyInformationType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<yardl::Date, yardl::binary::WriteDate>(stream, value.study_date);
  yardl::binary::WriteOptional<yardl::Time, yardl::binary::WriteTime>(stream, value.study_time);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.study_id);
  yardl::binary::WriteOptional<int64_t, yardl::binary::WriteInteger>(stream, value.accession_number);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.referring_physician_name);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.study_description);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.study_instance_uid);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.body_part_examined);
}

[[maybe_unused]] void ReadStudyInformationType(yardl::binary::CodedInputStream& stream, mrd::StudyInformationType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::StudyInformationType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<yardl::Date, yardl::binary::ReadDate>(stream, value.study_date);
  yardl::binary::ReadOptional<yardl::Time, yardl::binary::ReadTime>(stream, value.study_time);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.study_id);
  yardl::binary::ReadOptional<int64_t, yardl::binary::ReadInteger>(stream, value.accession_number);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.referring_physician_name);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.study_description);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.study_instance_uid);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.body_part_examined);
}

[[maybe_unused]] void WriteThreeDimensionalFloat(yardl::binary::CodedOutputStream& stream, mrd::ThreeDimensionalFloat const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ThreeDimensionalFloat>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.x);
  yardl::binary::WriteFloatingPoint(stream, value.y);
  yardl::binary::WriteFloatingPoint(stream, value.z);
}

[[maybe_unused]] void ReadThreeDimensionalFloat(yardl::binary::CodedInputStream& stream, mrd::ThreeDimensionalFloat& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ThreeDimensionalFloat>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.x);
  yardl::binary::ReadFloatingPoint(stream, value.y);
  yardl::binary::ReadFloatingPoint(stream, value.z);
}

[[maybe_unused]] void WriteMeasurementDependencyType(yardl::binary::CodedOutputStream& stream, mrd::MeasurementDependencyType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MeasurementDependencyType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.dependency_type);
  yardl::binary::WriteString(stream, value.measurement_id);
}

[[maybe_unused]] void ReadMeasurementDependencyType(yardl::binary::CodedInputStream& stream, mrd::MeasurementDependencyType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MeasurementDependencyType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.dependency_type);
  yardl::binary::ReadString(stream, value.measurement_id);
}

[[maybe_unused]] void WriteReferencedImageSequenceType(yardl::binary::CodedOutputStream& stream, mrd::ReferencedImageSequenceType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ReferencedImageSequenceType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<std::string, yardl::binary::WriteString>(stream, value.referenced_sop_instance_uid);
}

[[maybe_unused]] void ReadReferencedImageSequenceType(yardl::binary::CodedInputStream& stream, mrd::ReferencedImageSequenceType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ReferencedImageSequenceType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<std::string, yardl::binary::ReadString>(stream, value.referenced_sop_instance_uid);
}

[[maybe_unused]] void WriteMeasurementInformationType(yardl::binary::CodedOutputStream& stream, mrd::MeasurementInformationType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MeasurementInformationType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.measurement_id);
  yardl::binary::WriteOptional<yardl::Date, yardl::binary::WriteDate>(stream, value.series_date);
  yardl::binary::WriteOptional<yardl::Time, yardl::binary::WriteTime>(stream, value.series_time);
  yardl::binary::WriteEnum<mrd::PatientPosition>(stream, value.patient_position);
  yardl::binary::WriteOptional<mrd::ThreeDimensionalFloat, mrd::binary::WriteThreeDimensionalFloat>(stream, value.relative_table_position);
  yardl::binary::WriteOptional<int64_t, yardl::binary::WriteInteger>(stream, value.initial_series_number);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.protocol_name);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.sequence_name);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.series_description);
  yardl::binary::WriteVector<mrd::MeasurementDependencyType, mrd::binary::WriteMeasurementDependencyType>(stream, value.measurement_dependency);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.series_instance_uid_root);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.frame_of_reference_uid);
  yardl::binary::WriteOptional<mrd::ReferencedImageSequenceType, mrd::binary::WriteReferencedImageSequenceType>(stream, value.referenced_image_sequence);
}

[[maybe_unused]] void ReadMeasurementInformationType(yardl::binary::CodedInputStream& stream, mrd::MeasurementInformationType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MeasurementInformationType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.measurement_id);
  yardl::binary::ReadOptional<yardl::Date, yardl::binary::ReadDate>(stream, value.series_date);
  yardl::binary::ReadOptional<yardl::Time, yardl::binary::ReadTime>(stream, value.series_time);
  yardl::binary::ReadEnum<mrd::PatientPosition>(stream, value.patient_position);
  yardl::binary::ReadOptional<mrd::ThreeDimensionalFloat, mrd::binary::ReadThreeDimensionalFloat>(stream, value.relative_table_position);
  yardl::binary::ReadOptional<int64_t, yardl::binary::ReadInteger>(stream, value.initial_series_number);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.protocol_name);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.sequence_name);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.series_description);
  yardl::binary::ReadVector<mrd::MeasurementDependencyType, mrd::binary::ReadMeasurementDependencyType>(stream, value.measurement_dependency);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.series_instance_uid_root);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.frame_of_reference_uid);
  yardl::binary::ReadOptional<mrd::ReferencedImageSequenceType, mrd::binary::ReadReferencedImageSequenceType>(stream, value.referenced_image_sequence);
}

[[maybe_unused]] void WriteCoilLabelType(yardl::binary::CodedOutputStream& stream, mrd::CoilLabelType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::CoilLabelType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.coil_number);
  yardl::binary::WriteString(stream, value.coil_name);
}

[[maybe_unused]] void ReadCoilLabelType(yardl::binary::CodedInputStream& stream, mrd::CoilLabelType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::CoilLabelType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.coil_number);
  yardl::binary::ReadString(stream, value.coil_name);
}

[[maybe_unused]] void WriteAcquisitionSystemInformationType(yardl::binary::CodedOutputStream& stream, mrd::AcquisitionSystemInformationType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::AcquisitionSystemInformationType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.system_vendor);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.system_model);
  yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream, value.system_field_strength_t);
  yardl::binary::WriteOptional<float, yardl::binary::WriteFloatingPoint>(stream, value.relative_receiver_noise_bandwidth);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.receiver_channels);
  yardl::binary::WriteVector<mrd::CoilLabelType, mrd::binary::WriteCoilLabelType>(stream, value.coil_label);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.institution_name);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.station_name);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.device_id);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.device_serial_number);
}

[[maybe_unused]] void ReadAcquisitionSystemInformationType(yardl::binary::CodedInputStream& stream, mrd::AcquisitionSystemInformationType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::AcquisitionSystemInformationType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.system_vendor);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.system_model);
  yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream, value.system_field_strength_t);
  yardl::binary::ReadOptional<float, yardl::binary::ReadFloatingPoint>(stream, value.relative_receiver_noise_bandwidth);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.receiver_channels);
  yardl::binary::ReadVector<mrd::CoilLabelType, mrd::binary::ReadCoilLabelType>(stream, value.coil_label);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.institution_name);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.station_name);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.device_id);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.device_serial_number);
}

[[maybe_unused]] void WriteExperimentalConditionsType(yardl::binary::CodedOutputStream& stream, mrd::ExperimentalConditionsType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ExperimentalConditionsType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.h1resonance_frequency_hz);
}

[[maybe_unused]] void ReadExperimentalConditionsType(yardl::binary::CodedInputStream& stream, mrd::ExperimentalConditionsType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ExperimentalConditionsType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.h1resonance_frequency_hz);
}

[[maybe_unused]] void WriteMatrixSizeType(yardl::binary::CodedOutputStream& stream, mrd::MatrixSizeType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MatrixSizeType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.x);
  yardl::binary::WriteInteger(stream, value.y);
  yardl::binary::WriteInteger(stream, value.z);
}

[[maybe_unused]] void ReadMatrixSizeType(yardl::binary::CodedInputStream& stream, mrd::MatrixSizeType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MatrixSizeType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.x);
  yardl::binary::ReadInteger(stream, value.y);
  yardl::binary::ReadInteger(stream, value.z);
}

[[maybe_unused]] void WriteFieldOfViewMm(yardl::binary::CodedOutputStream& stream, mrd::FieldOfViewMm const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::FieldOfViewMm>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.x);
  yardl::binary::WriteFloatingPoint(stream, value.y);
  yardl::binary::WriteFloatingPoint(stream, value.z);
}

[[maybe_unused]] void ReadFieldOfViewMm(yardl::binary::CodedInputStream& stream, mrd::FieldOfViewMm& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::FieldOfViewMm>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.x);
  yardl::binary::ReadFloatingPoint(stream, value.y);
  yardl::binary::ReadFloatingPoint(stream, value.z);
}

[[maybe_unused]] void WriteEncodingSpaceType(yardl::binary::CodedOutputStream& stream, mrd::EncodingSpaceType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingSpaceType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteMatrixSizeType(stream, value.matrix_size);
  mrd::binary::WriteFieldOfViewMm(stream, value.field_of_view_mm);
}

[[maybe_unused]] void ReadEncodingSpaceType(yardl::binary::CodedInputStream& stream, mrd::EncodingSpaceType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingSpaceType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadMatrixSizeType(stream, value.matrix_size);
  mrd::binary::ReadFieldOfViewMm(stream, value.field_of_view_mm);
}

[[maybe_unused]] void WriteLimitType(yardl::binary::CodedOutputStream& stream, mrd::LimitType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::LimitType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.minimum);
  yardl::binary::WriteInteger(stream, value.maximum);
  yardl::binary::WriteInteger(stream, value.center);
}

[[maybe_unused]] void ReadLimitType(yardl::binary::CodedInputStream& stream, mrd::LimitType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::LimitType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.minimum);
  yardl::binary::ReadInteger(stream, value.maximum);
  yardl::binary::ReadInteger(stream, value.center);
}

[[maybe_unused]] void WriteEncodingLimitsType(yardl::binary::CodedOutputStream& stream, mrd::EncodingLimitsType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingLimitsType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.kspace_encoding_step_0);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.kspace_encoding_step_1);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.kspace_encoding_step_2);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.average);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.slice);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.contrast);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.phase);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.repetition);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.set);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.segment);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_0);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_1);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_2);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_3);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_4);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_5);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_6);
  yardl::binary::WriteOptional<mrd::LimitType, mrd::binary::WriteLimitType>(stream, value.user_7);
}

[[maybe_unused]] void ReadEncodingLimitsType(yardl::binary::CodedInputStream& stream, mrd::EncodingLimitsType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingLimitsType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.kspace_encoding_step_0);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.kspace_encoding_step_1);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.kspace_encoding_step_2);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.average);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.slice);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.contrast);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.phase);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.repetition);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.set);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.segment);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_0);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_1);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_2);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_3);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_4);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_5);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_6);
  yardl::binary::ReadOptional<mrd::LimitType, mrd::binary::ReadLimitType>(stream, value.user_7);
}

[[maybe_unused]] void WriteUserParameterLongType(yardl::binary::CodedOutputStream& stream, mrd::UserParameterLongType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterLongType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteInteger(stream, value.value);
}

[[maybe_unused]] void ReadUserParameterLongType(yardl::binary::CodedInputStream& stream, mrd::UserParameterLongType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterLongType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadInteger(stream, value.value);
}

[[maybe_unused]] void WriteUserParameterDoubleType(yardl::binary::CodedOutputStream& stream, mrd::UserParameterDoubleType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterDoubleType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteFloatingPoint(stream, value.value);
}

[[maybe_unused]] void ReadUserParameterDoubleType(yardl::binary::CodedInputStream& stream, mrd::UserParameterDoubleType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterDoubleType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadFloatingPoint(stream, value.value);
}

[[maybe_unused]] void WriteUserParameterStringType(yardl::binary::CodedOutputStream& stream, mrd::UserParameterStringType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterStringType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteString(stream, value.value);
}

[[maybe_unused]] void ReadUserParameterStringType(yardl::binary::CodedInputStream& stream, mrd::UserParameterStringType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterStringType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadString(stream, value.value);
}

[[maybe_unused]] void WriteTrajectoryDescriptionType(yardl::binary::CodedOutputStream& stream, mrd::TrajectoryDescriptionType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::TrajectoryDescriptionType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.identifier);
  yardl::binary::WriteVector<mrd::UserParameterLongType, mrd::binary::WriteUserParameterLongType>(stream, value.user_parameter_long);
  yardl::binary::WriteVector<mrd::UserParameterDoubleType, mrd::binary::WriteUserParameterDoubleType>(stream, value.user_parameter_double);
  yardl::binary::WriteVector<mrd::UserParameterStringType, mrd::binary::WriteUserParameterStringType>(stream, value.user_parameter_string);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.comment);
}

[[maybe_unused]] void ReadTrajectoryDescriptionType(yardl::binary::CodedInputStream& stream, mrd::TrajectoryDescriptionType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::TrajectoryDescriptionType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.identifier);
  yardl::binary::ReadVector<mrd::UserParameterLongType, mrd::binary::ReadUserParameterLongType>(stream, value.user_parameter_long);
  yardl::binary::ReadVector<mrd::UserParameterDoubleType, mrd::binary::ReadUserParameterDoubleType>(stream, value.user_parameter_double);
  yardl::binary::ReadVector<mrd::UserParameterStringType, mrd::binary::ReadUserParameterStringType>(stream, value.user_parameter_string);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.comment);
}

[[maybe_unused]] void WriteAccelerationFactorType(yardl::binary::CodedOutputStream& stream, mrd::AccelerationFactorType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::AccelerationFactorType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.kspace_encoding_step_1);
  yardl::binary::WriteInteger(stream, value.kspace_encoding_step_2);
}

[[maybe_unused]] void ReadAccelerationFactorType(yardl::binary::CodedInputStream& stream, mrd::AccelerationFactorType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::AccelerationFactorType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.kspace_encoding_step_1);
  yardl::binary::ReadInteger(stream, value.kspace_encoding_step_2);
}

[[maybe_unused]] void WriteMultibandSpacingType(yardl::binary::CodedOutputStream& stream, mrd::MultibandSpacingType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MultibandSpacingType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.d_z);
}

[[maybe_unused]] void ReadMultibandSpacingType(yardl::binary::CodedInputStream& stream, mrd::MultibandSpacingType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MultibandSpacingType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.d_z);
}

[[maybe_unused]] void WriteMultibandType(yardl::binary::CodedOutputStream& stream, mrd::MultibandType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MultibandType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<mrd::MultibandSpacingType, mrd::binary::WriteMultibandSpacingType>(stream, value.spacing);
  yardl::binary::WriteFloatingPoint(stream, value.delta_kz);
  yardl::binary::WriteInteger(stream, value.multiband_factor);
  yardl::binary::WriteEnum<mrd::Calibration>(stream, value.calibration);
  yardl::binary::WriteInteger(stream, value.calibration_encoding);
}

[[maybe_unused]] void ReadMultibandType(yardl::binary::CodedInputStream& stream, mrd::MultibandType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::MultibandType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<mrd::MultibandSpacingType, mrd::binary::ReadMultibandSpacingType>(stream, value.spacing);
  yardl::binary::ReadFloatingPoint(stream, value.delta_kz);
  yardl::binary::ReadInteger(stream, value.multiband_factor);
  yardl::binary::ReadEnum<mrd::Calibration>(stream, value.calibration);
  yardl::binary::ReadInteger(stream, value.calibration_encoding);
}

[[maybe_unused]] void WriteParallelImagingType(yardl::binary::CodedOutputStream& stream, mrd::ParallelImagingType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ParallelImagingType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteAccelerationFactorType(stream, value.acceleration_factor);
  yardl::binary::WriteOptional<mrd::CalibrationMode, yardl::binary::WriteEnum<mrd::CalibrationMode>>(stream, value.calibration_mode);
  yardl::binary::WriteOptional<mrd::InterleavingDimension, yardl::binary::WriteEnum<mrd::InterleavingDimension>>(stream, value.interleaving_dimension);
  yardl::binary::WriteOptional<mrd::MultibandType, mrd::binary::WriteMultibandType>(stream, value.multiband);
}

[[maybe_unused]] void ReadParallelImagingType(yardl::binary::CodedInputStream& stream, mrd::ParallelImagingType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ParallelImagingType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadAccelerationFactorType(stream, value.acceleration_factor);
  yardl::binary::ReadOptional<mrd::CalibrationMode, yardl::binary::ReadEnum<mrd::CalibrationMode>>(stream, value.calibration_mode);
  yardl::binary::ReadOptional<mrd::InterleavingDimension, yardl::binary::ReadEnum<mrd::InterleavingDimension>>(stream, value.interleaving_dimension);
  yardl::binary::ReadOptional<mrd::MultibandType, mrd::binary::ReadMultibandType>(stream, value.multiband);
}

[[maybe_unused]] void WriteEncodingType(yardl::binary::CodedOutputStream& stream, mrd::EncodingType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteEncodingSpaceType(stream, value.encoded_space);
  mrd::binary::WriteEncodingSpaceType(stream, value.recon_space);
  mrd::binary::WriteEncodingLimitsType(stream, value.encoding_limits);
  yardl::binary::WriteEnum<mrd::Trajectory>(stream, value.trajectory);
  yardl::binary::WriteOptional<mrd::TrajectoryDescriptionType, mrd::binary::WriteTrajectoryDescriptionType>(stream, value.trajectory_description);
  yardl::binary::WriteOptional<mrd::ParallelImagingType, mrd::binary::WriteParallelImagingType>(stream, value.parallel_imaging);
  yardl::binary::WriteOptional<int64_t, yardl::binary::WriteInteger>(stream, value.echo_train_length);
}

[[maybe_unused]] void ReadEncodingType(yardl::binary::CodedInputStream& stream, mrd::EncodingType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::EncodingType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadEncodingSpaceType(stream, value.encoded_space);
  mrd::binary::ReadEncodingSpaceType(stream, value.recon_space);
  mrd::binary::ReadEncodingLimitsType(stream, value.encoding_limits);
  yardl::binary::ReadEnum<mrd::Trajectory>(stream, value.trajectory);
  yardl::binary::ReadOptional<mrd::TrajectoryDescriptionType, mrd::binary::ReadTrajectoryDescriptionType>(stream, value.trajectory_description);
  yardl::binary::ReadOptional<mrd::ParallelImagingType, mrd::binary::ReadParallelImagingType>(stream, value.parallel_imaging);
  yardl::binary::ReadOptional<int64_t, yardl::binary::ReadInteger>(stream, value.echo_train_length);
}

[[maybe_unused]] void WriteGradientDirectionType(yardl::binary::CodedOutputStream& stream, mrd::GradientDirectionType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::GradientDirectionType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.rl);
  yardl::binary::WriteFloatingPoint(stream, value.ap);
  yardl::binary::WriteFloatingPoint(stream, value.fh);
}

[[maybe_unused]] void ReadGradientDirectionType(yardl::binary::CodedInputStream& stream, mrd::GradientDirectionType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::GradientDirectionType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.rl);
  yardl::binary::ReadFloatingPoint(stream, value.ap);
  yardl::binary::ReadFloatingPoint(stream, value.fh);
}

[[maybe_unused]] void WriteDiffusionType(yardl::binary::CodedOutputStream& stream, mrd::DiffusionType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::DiffusionType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteGradientDirectionType(stream, value.gradient_direction);
  yardl::binary::WriteFloatingPoint(stream, value.bvalue);
}

[[maybe_unused]] void ReadDiffusionType(yardl::binary::CodedInputStream& stream, mrd::DiffusionType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::DiffusionType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadGradientDirectionType(stream, value.gradient_direction);
  yardl::binary::ReadFloatingPoint(stream, value.bvalue);
}

[[maybe_unused]] void WriteSequenceParametersType(yardl::binary::CodedOutputStream& stream, mrd::SequenceParametersType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::SequenceParametersType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.t_r);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.t_e);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.t_i);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.flip_angle_deg);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.sequence_type);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.echo_spacing);
  yardl::binary::WriteOptional<mrd::DiffusionDimension, yardl::binary::WriteEnum<mrd::DiffusionDimension>>(stream, value.diffusion_dimension);
  yardl::binary::WriteVector<mrd::DiffusionType, mrd::binary::WriteDiffusionType>(stream, value.diffusion);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.diffusion_scheme);
}

[[maybe_unused]] void ReadSequenceParametersType(yardl::binary::CodedInputStream& stream, mrd::SequenceParametersType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::SequenceParametersType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.t_r);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.t_e);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.t_i);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.flip_angle_deg);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.sequence_type);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.echo_spacing);
  yardl::binary::ReadOptional<mrd::DiffusionDimension, yardl::binary::ReadEnum<mrd::DiffusionDimension>>(stream, value.diffusion_dimension);
  yardl::binary::ReadVector<mrd::DiffusionType, mrd::binary::ReadDiffusionType>(stream, value.diffusion);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.diffusion_scheme);
}

[[maybe_unused]] void WriteUserParameterBase64Type(yardl::binary::CodedOutputStream& stream, mrd::UserParameterBase64Type const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterBase64Type>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteString(stream, value.value);
}

[[maybe_unused]] void ReadUserParameterBase64Type(yardl::binary::CodedInputStream& stream, mrd::UserParameterBase64Type& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParameterBase64Type>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadString(stream, value.value);
}

[[maybe_unused]] void WriteUserParametersType(yardl::binary::CodedOutputStream& stream, mrd::UserParametersType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParametersType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<mrd::UserParameterLongType, mrd::binary::WriteUserParameterLongType>(stream, value.user_parameter_long);
  yardl::binary::WriteVector<mrd::UserParameterDoubleType, mrd::binary::WriteUserParameterDoubleType>(stream, value.user_parameter_double);
  yardl::binary::WriteVector<mrd::UserParameterStringType, mrd::binary::WriteUserParameterStringType>(stream, value.user_parameter_string);
  yardl::binary::WriteVector<mrd::UserParameterBase64Type, mrd::binary::WriteUserParameterBase64Type>(stream, value.user_parameter_base64);
}

[[maybe_unused]] void ReadUserParametersType(yardl::binary::CodedInputStream& stream, mrd::UserParametersType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::UserParametersType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<mrd::UserParameterLongType, mrd::binary::ReadUserParameterLongType>(stream, value.user_parameter_long);
  yardl::binary::ReadVector<mrd::UserParameterDoubleType, mrd::binary::ReadUserParameterDoubleType>(stream, value.user_parameter_double);
  yardl::binary::ReadVector<mrd::UserParameterStringType, mrd::binary::ReadUserParameterStringType>(stream, value.user_parameter_string);
  yardl::binary::ReadVector<mrd::UserParameterBase64Type, mrd::binary::ReadUserParameterBase64Type>(stream, value.user_parameter_base64);
}

[[maybe_unused]] void WriteWaveformInformationType(yardl::binary::CodedOutputStream& stream, mrd::WaveformInformationType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::WaveformInformationType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.waveform_name);
  yardl::binary::WriteEnum<mrd::WaveformType>(stream, value.waveform_type);
  mrd::binary::WriteUserParametersType(stream, value.user_parameters);
}

[[maybe_unused]] void ReadWaveformInformationType(yardl::binary::CodedInputStream& stream, mrd::WaveformInformationType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::WaveformInformationType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.waveform_name);
  yardl::binary::ReadEnum<mrd::WaveformType>(stream, value.waveform_type);
  mrd::binary::ReadUserParametersType(stream, value.user_parameters);
}

[[maybe_unused]] void WriteHeader(yardl::binary::CodedOutputStream& stream, mrd::Header const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Header>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<int64_t, yardl::binary::WriteInteger>(stream, value.version);
  yardl::binary::WriteOptional<mrd::SubjectInformationType, mrd::binary::WriteSubjectInformationType>(stream, value.subject_information);
  yardl::binary::WriteOptional<mrd::StudyInformationType, mrd::binary::WriteStudyInformationType>(stream, value.study_information);
  yardl::binary::WriteOptional<mrd::MeasurementInformationType, mrd::binary::WriteMeasurementInformationType>(stream, value.measurement_information);
  yardl::binary::WriteOptional<mrd::AcquisitionSystemInformationType, mrd::binary::WriteAcquisitionSystemInformationType>(stream, value.acquisition_system_information);
  mrd::binary::WriteExperimentalConditionsType(stream, value.experimental_conditions);
  yardl::binary::WriteVector<mrd::EncodingType, mrd::binary::WriteEncodingType>(stream, value.encoding);
  yardl::binary::WriteOptional<mrd::SequenceParametersType, mrd::binary::WriteSequenceParametersType>(stream, value.sequence_parameters);
  yardl::binary::WriteOptional<mrd::UserParametersType, mrd::binary::WriteUserParametersType>(stream, value.user_parameters);
  yardl::binary::WriteVector<mrd::WaveformInformationType, mrd::binary::WriteWaveformInformationType>(stream, value.waveform_information);
}

[[maybe_unused]] void ReadHeader(yardl::binary::CodedInputStream& stream, mrd::Header& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Header>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<int64_t, yardl::binary::ReadInteger>(stream, value.version);
  yardl::binary::ReadOptional<mrd::SubjectInformationType, mrd::binary::ReadSubjectInformationType>(stream, value.subject_information);
  yardl::binary::ReadOptional<mrd::StudyInformationType, mrd::binary::ReadStudyInformationType>(stream, value.study_information);
  yardl::binary::ReadOptional<mrd::MeasurementInformationType, mrd::binary::ReadMeasurementInformationType>(stream, value.measurement_information);
  yardl::binary::ReadOptional<mrd::AcquisitionSystemInformationType, mrd::binary::ReadAcquisitionSystemInformationType>(stream, value.acquisition_system_information);
  mrd::binary::ReadExperimentalConditionsType(stream, value.experimental_conditions);
  yardl::binary::ReadVector<mrd::EncodingType, mrd::binary::ReadEncodingType>(stream, value.encoding);
  yardl::binary::ReadOptional<mrd::SequenceParametersType, mrd::binary::ReadSequenceParametersType>(stream, value.sequence_parameters);
  yardl::binary::ReadOptional<mrd::UserParametersType, mrd::binary::ReadUserParametersType>(stream, value.user_parameters);
  yardl::binary::ReadVector<mrd::WaveformInformationType, mrd::binary::ReadWaveformInformationType>(stream, value.waveform_information);
}

template<typename Y, yardl::binary::Writer<Y> WriteY>
[[maybe_unused]] void WriteImageData(yardl::binary::CodedOutputStream& stream, mrd::ImageData<Y> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageData<Y>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<Y, WriteY, 4>(stream, value);
}

template<typename Y, yardl::binary::Reader<Y> ReadY>
[[maybe_unused]] void ReadImageData(yardl::binary::CodedInputStream& stream, mrd::ImageData<Y>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageData<Y>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<Y, ReadY, 4>(stream, value);
}

[[maybe_unused]] void WriteImageMetaData(yardl::binary::CodedOutputStream& stream, mrd::ImageMetaData const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageMetaData>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteString(stream, value.value);
}

[[maybe_unused]] void ReadImageMetaData(yardl::binary::CodedInputStream& stream, mrd::ImageMetaData& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageMetaData>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadString(stream, value.value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteImage(yardl::binary::CodedOutputStream& stream, mrd::Image<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Image<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFlags<mrd::ImageFlags>(stream, value.flags);
  yardl::binary::WriteInteger(stream, value.measurement_uid);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.field_of_view);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.position);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.col_dir);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.line_dir);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.slice_dir);
  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.patient_table_position);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.average);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.slice);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.contrast);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.phase);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.repetition);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.set);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.acquisition_time_stamp);
  yardl::binary::WriteFixedNDArray<uint32_t, yardl::binary::WriteInteger, 3>(stream, value.physiology_time_stamp);
  yardl::binary::WriteEnum<mrd::ImageType>(stream, value.image_type);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.image_index);
  yardl::binary::WriteOptional<uint32_t, yardl::binary::WriteInteger>(stream, value.image_series_index);
  yardl::binary::WriteVector<int32_t, yardl::binary::WriteInteger>(stream, value.user_int);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.user_float);
  mrd::binary::WriteImageData<T, WriteT>(stream, value.data);
  yardl::binary::WriteMap<std::string, std::vector<std::string>, yardl::binary::WriteString, yardl::binary::WriteVector<std::string, yardl::binary::WriteString>>(stream, value.meta);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadImage(yardl::binary::CodedInputStream& stream, mrd::Image<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Image<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFlags<mrd::ImageFlags>(stream, value.flags);
  yardl::binary::ReadInteger(stream, value.measurement_uid);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.field_of_view);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.position);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.col_dir);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.line_dir);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.slice_dir);
  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.patient_table_position);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.average);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.slice);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.contrast);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.phase);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.repetition);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.set);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.acquisition_time_stamp);
  yardl::binary::ReadFixedNDArray<uint32_t, yardl::binary::ReadInteger, 3>(stream, value.physiology_time_stamp);
  yardl::binary::ReadEnum<mrd::ImageType>(stream, value.image_type);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.image_index);
  yardl::binary::ReadOptional<uint32_t, yardl::binary::ReadInteger>(stream, value.image_series_index);
  yardl::binary::ReadVector<int32_t, yardl::binary::ReadInteger>(stream, value.user_int);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.user_float);
  mrd::binary::ReadImageData<T, ReadT>(stream, value.data);
  yardl::binary::ReadMap<std::string, std::vector<std::string>, yardl::binary::ReadString, yardl::binary::ReadVector<std::string, yardl::binary::ReadString>>(stream, value.meta);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteWaveformSamples(yardl::binary::CodedOutputStream& stream, mrd::WaveformSamples<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::WaveformSamples<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteNDArray<T, WriteT, 2>(stream, value);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadWaveformSamples(yardl::binary::CodedInputStream& stream, mrd::WaveformSamples<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::WaveformSamples<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadNDArray<T, ReadT, 2>(stream, value);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteWaveform(yardl::binary::CodedOutputStream& stream, mrd::Waveform<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Waveform<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.flags);
  yardl::binary::WriteInteger(stream, value.measurement_uid);
  yardl::binary::WriteInteger(stream, value.scan_counter);
  yardl::binary::WriteInteger(stream, value.time_stamp);
  yardl::binary::WriteFloatingPoint(stream, value.sample_time_us);
  yardl::binary::WriteInteger(stream, value.waveform_id);
  mrd::binary::WriteWaveformSamples<T, WriteT>(stream, value.data);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadWaveform(yardl::binary::CodedInputStream& stream, mrd::Waveform<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::Waveform<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.flags);
  yardl::binary::ReadInteger(stream, value.measurement_uid);
  yardl::binary::ReadInteger(stream, value.scan_counter);
  yardl::binary::ReadInteger(stream, value.time_stamp);
  yardl::binary::ReadFloatingPoint(stream, value.sample_time_us);
  yardl::binary::ReadInteger(stream, value.waveform_id);
  mrd::binary::ReadWaveformSamples<T, ReadT>(stream, value.data);
}

[[maybe_unused]] void WriteWaveformUint32(yardl::binary::CodedOutputStream& stream, mrd::WaveformUint32 const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::WaveformUint32>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteWaveform<uint32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadWaveformUint32(yardl::binary::CodedInputStream& stream, mrd::WaveformUint32& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::WaveformUint32>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadWaveform<uint32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteImageUint16(yardl::binary::CodedOutputStream& stream, mrd::ImageUint16 const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageUint16>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<uint16_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadImageUint16(yardl::binary::CodedInputStream& stream, mrd::ImageUint16& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageUint16>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<uint16_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteImageInt16(yardl::binary::CodedOutputStream& stream, mrd::ImageInt16 const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageInt16>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<int16_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadImageInt16(yardl::binary::CodedInputStream& stream, mrd::ImageInt16& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageInt16>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<int16_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteImageUint(yardl::binary::CodedOutputStream& stream, mrd::ImageUint const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageUint>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<uint32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadImageUint(yardl::binary::CodedInputStream& stream, mrd::ImageUint& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageUint>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<uint32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteImageInt(yardl::binary::CodedOutputStream& stream, mrd::ImageInt const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageInt>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<int32_t, yardl::binary::WriteInteger>(stream, value);
}

[[maybe_unused]] void ReadImageInt(yardl::binary::CodedInputStream& stream, mrd::ImageInt& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageInt>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<int32_t, yardl::binary::ReadInteger>(stream, value);
}

[[maybe_unused]] void WriteImageFloat(yardl::binary::CodedOutputStream& stream, mrd::ImageFloat const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageFloat>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<float, yardl::binary::WriteFloatingPoint>(stream, value);
}

[[maybe_unused]] void ReadImageFloat(yardl::binary::CodedInputStream& stream, mrd::ImageFloat& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageFloat>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<float, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteImageDouble(yardl::binary::CodedOutputStream& stream, mrd::ImageDouble const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageDouble>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<double, yardl::binary::WriteFloatingPoint>(stream, value);
}

[[maybe_unused]] void ReadImageDouble(yardl::binary::CodedInputStream& stream, mrd::ImageDouble& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageDouble>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<double, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteImageComplexFloat(yardl::binary::CodedOutputStream& stream, mrd::ImageComplexFloat const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageComplexFloat>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<std::complex<float>, yardl::binary::WriteFloatingPoint>(stream, value);
}

[[maybe_unused]] void ReadImageComplexFloat(yardl::binary::CodedInputStream& stream, mrd::ImageComplexFloat& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageComplexFloat>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<std::complex<float>, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteImageComplexDouble(yardl::binary::CodedOutputStream& stream, mrd::ImageComplexDouble const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageComplexDouble>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::WriteImage<std::complex<double>, yardl::binary::WriteFloatingPoint>(stream, value);
}

[[maybe_unused]] void ReadImageComplexDouble(yardl::binary::CodedInputStream& stream, mrd::ImageComplexDouble& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::ImageComplexDouble>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  mrd::binary::ReadImage<std::complex<double>, yardl::binary::ReadFloatingPoint>(stream, value);
}

[[maybe_unused]] void WriteStreamItem(yardl::binary::CodedOutputStream& stream, mrd::StreamItem const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::StreamItem>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<mrd::Acquisition, mrd::binary::WriteAcquisition, mrd::WaveformUint32, mrd::binary::WriteWaveformUint32, mrd::ImageUint16, mrd::binary::WriteImageUint16, mrd::ImageInt16, mrd::binary::WriteImageInt16, mrd::ImageUint, mrd::binary::WriteImageUint, mrd::ImageInt, mrd::binary::WriteImageInt, mrd::ImageFloat, mrd::binary::WriteImageFloat, mrd::ImageDouble, mrd::binary::WriteImageDouble, mrd::ImageComplexFloat, mrd::binary::WriteImageComplexFloat, mrd::ImageComplexDouble, mrd::binary::WriteImageComplexDouble>(stream, value);
}

[[maybe_unused]] void ReadStreamItem(yardl::binary::CodedInputStream& stream, mrd::StreamItem& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<mrd::StreamItem>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<mrd::Acquisition, mrd::binary::ReadAcquisition, mrd::WaveformUint32, mrd::binary::ReadWaveformUint32, mrd::ImageUint16, mrd::binary::ReadImageUint16, mrd::ImageInt16, mrd::binary::ReadImageInt16, mrd::ImageUint, mrd::binary::ReadImageUint, mrd::ImageInt, mrd::binary::ReadImageInt, mrd::ImageFloat, mrd::binary::ReadImageFloat, mrd::ImageDouble, mrd::binary::ReadImageDouble, mrd::ImageComplexFloat, mrd::binary::ReadImageComplexFloat, mrd::ImageComplexDouble, mrd::binary::ReadImageComplexDouble>(stream, value);
}

} // namespace

void MrdWriter::WriteHeaderImpl(std::optional<mrd::Header> const& value) {
  yardl::binary::WriteOptional<mrd::Header, mrd::binary::WriteHeader>(stream_, value);
}

void MrdWriter::WriteDataImpl(mrd::StreamItem const& value) {
  yardl::binary::WriteBlock<mrd::StreamItem, mrd::binary::WriteStreamItem>(stream_, value);
}

void MrdWriter::WriteDataImpl(std::vector<mrd::StreamItem> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<mrd::StreamItem, mrd::binary::WriteStreamItem>(stream_, values);
  }
}

void MrdWriter::EndDataImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void MrdWriter::Flush() {
  stream_.Flush();
}

void MrdWriter::CloseImpl() {
  stream_.Flush();
}

void MrdReader::ReadHeaderImpl(std::optional<mrd::Header>& value) {
  yardl::binary::ReadOptional<mrd::Header, mrd::binary::ReadHeader>(stream_, value);
}

bool MrdReader::ReadDataImpl(mrd::StreamItem& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<mrd::StreamItem, mrd::binary::ReadStreamItem>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool MrdReader::ReadDataImpl(std::vector<mrd::StreamItem>& values) {
  yardl::binary::ReadBlocksIntoVector<mrd::StreamItem, mrd::binary::ReadStreamItem>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void MrdReader::CloseImpl() {
  stream_.VerifyFinished();
}

} // namespace mrd::binary

