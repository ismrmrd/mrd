% This file was generated by the "yardl" tool. DO NOT EDIT.

classdef MeasurementInformationType < handle
  properties
    measurement_id
    series_date
    series_time
    patient_position
    relative_table_position
    initial_series_number
    protocol_name
    sequence_name
    series_description
    measurement_dependency
    series_instance_uid_root
    frame_of_reference_uid
    referenced_image_sequence
  end

  methods
    function self = MeasurementInformationType(kwargs)
      arguments
        kwargs.measurement_id = yardl.None;
        kwargs.series_date = yardl.None;
        kwargs.series_time = yardl.None;
        kwargs.patient_position = mrd.PatientPosition.H_FP;
        kwargs.relative_table_position = yardl.None;
        kwargs.initial_series_number = yardl.None;
        kwargs.protocol_name = yardl.None;
        kwargs.sequence_name = yardl.None;
        kwargs.series_description = yardl.None;
        kwargs.measurement_dependency = mrd.MeasurementDependencyType.empty();
        kwargs.series_instance_uid_root = yardl.None;
        kwargs.frame_of_reference_uid = yardl.None;
        kwargs.referenced_image_sequence = yardl.None;
      end
      self.measurement_id = kwargs.measurement_id;
      self.series_date = kwargs.series_date;
      self.series_time = kwargs.series_time;
      self.patient_position = kwargs.patient_position;
      self.relative_table_position = kwargs.relative_table_position;
      self.initial_series_number = kwargs.initial_series_number;
      self.protocol_name = kwargs.protocol_name;
      self.sequence_name = kwargs.sequence_name;
      self.series_description = kwargs.series_description;
      self.measurement_dependency = kwargs.measurement_dependency;
      self.series_instance_uid_root = kwargs.series_instance_uid_root;
      self.frame_of_reference_uid = kwargs.frame_of_reference_uid;
      self.referenced_image_sequence = kwargs.referenced_image_sequence;
    end

    function res = eq(self, other)
      res = ...
        isa(other, "mrd.MeasurementInformationType") && ...
        isequal({self.measurement_id}, {other.measurement_id}) && ...
        isequal({self.series_date}, {other.series_date}) && ...
        isequal({self.series_time}, {other.series_time}) && ...
        isequal({self.patient_position}, {other.patient_position}) && ...
        isequal({self.relative_table_position}, {other.relative_table_position}) && ...
        isequal({self.initial_series_number}, {other.initial_series_number}) && ...
        isequal({self.protocol_name}, {other.protocol_name}) && ...
        isequal({self.sequence_name}, {other.sequence_name}) && ...
        isequal({self.series_description}, {other.series_description}) && ...
        isequal({self.measurement_dependency}, {other.measurement_dependency}) && ...
        isequal({self.series_instance_uid_root}, {other.series_instance_uid_root}) && ...
        isequal({self.frame_of_reference_uid}, {other.frame_of_reference_uid}) && ...
        isequal({self.referenced_image_sequence}, {other.referenced_image_sequence});
    end

    function res = ne(self, other)
      res = ~self.eq(other);
    end

    function res = isequal(self, other)
      res = all(eq(self, other));
    end
  end

  methods (Static)
    function z = zeros(varargin)
      elem = mrd.MeasurementInformationType();
      if nargin == 0
        z = elem;
        return;
      end
      sz = [varargin{:}];
      if isscalar(sz)
        sz = [sz, sz];
      end
      z = reshape(repelem(elem, prod(sz)), sz);
    end
  end
end
